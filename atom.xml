<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xdCao&#39;s blog</title>
  
  
  <link href="https://blog.cuznlp.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.cuznlp.cn/"/>
  <updated>2023-08-27T15:03:11.423Z</updated>
  <id>https://blog.cuznlp.cn/</id>
  
  <author>
    <name>xdCao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一次数据倾斜导致的MYSQL优化错误</title>
    <link href="https://blog.cuznlp.cn/2023/08/27/%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E5%AF%BC%E8%87%B4%E7%9A%84MYSQL%E4%BC%98%E5%8C%96%E9%94%99%E8%AF%AF/"/>
    <id>https://blog.cuznlp.cn/2023/08/27/%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E5%AF%BC%E8%87%B4%E7%9A%84MYSQL%E4%BC%98%E5%8C%96%E9%94%99%E8%AF%AF/</id>
    <published>2023-08-27T14:05:35.000Z</published>
    <updated>2023-08-27T15:03:11.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>这个月某天晚上，IC的同学遇到一个诡异的问题，由于业务侧的开发同学(我们是中台)新增了一个索引，导致线上出现了较多的慢SQL，但是实际上线上明明有性能更好的索引，MYSQL却没有选择。<br>虽然我是做的商品发布，这件事貌似跟我没啥关系，但是，出于技术人的好奇心，加上这是一个很好的通过实践来加深对MYSQL理解的机会，我便想要一探究竟。</p><h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>线上出问题的是ic的图片表auction_image， 其中，线上原本的索引为：</p><p><code>idx_image_auction_id(auctionId,status)</code></p><p>而这次业务同学新增的索引为：</p><p><code>idx_image_sku_id(skuId, status)</code></p><p>其中一例慢SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `auction_image_0422` `auction_image` </span><br><span class="line"><span class="keyword">WHERE</span> (</span><br><span class="line">(`auction_image`.`sku_id` <span class="keyword">IN</span> (<span class="number">0</span>,<span class="number">1460251609</span>,<span class="number">1460251608</span>,<span class="number">1460251611</span>,<span class="number">1460251610</span>,<span class="number">1460251613</span>,<span class="number">1460251612</span>,<span class="number">1460251615</span>,<span class="number">1460251614</span>,<span class="number">1460251607</span>,<span class="number">1460251606</span>,<span class="number">1460251625</span>,<span class="number">1460251624</span>,<span class="number">1460251627</span>,<span class="number">1460251626</span>,<span class="number">1460251629</span>,<span class="number">1460251628</span>,<span class="number">1460251631</span>,<span class="number">1460251630</span>,<span class="number">1460251617</span>,<span class="number">1460251616</span>,<span class="number">1460251619</span>,<span class="number">1460251618</span>,<span class="number">1460251621</span>,<span class="number">1460251620</span>,<span class="number">1460251623</span>,<span class="number">1460251622</span>,<span class="number">1460251641</span>,<span class="number">1460251640</span>,<span class="number">1460251643</span>,<span class="number">1460251642</span>,<span class="number">1460251645</span>,<span class="number">1460251644</span>,<span class="number">1460251647</span>,<span class="number">1460251646</span>,<span class="number">1460251633</span>,<span class="number">1460251632</span>,<span class="number">1460251635</span>,<span class="number">1460251634</span>,<span class="number">1460251637</span>,<span class="number">1460251636</span>,<span class="number">1460251639</span>,<span class="number">1460251638</span>,<span class="number">1460251657</span>,<span class="number">1460251656</span>,<span class="number">1460251659</span>,<span class="number">1460251658</span>,<span class="number">1460251661</span>,<span class="number">1460251660</span>,<span class="number">1460251663</span>,<span class="number">1460251662</span>,<span class="number">1460251649</span>,<span class="number">1460251648</span>,<span class="number">1460251651</span>,<span class="number">1460251650</span>,<span class="number">1460251653</span>,<span class="number">1460251652</span>,<span class="number">1460251655</span>,<span class="number">1460251654</span>,<span class="number">1460251673</span>,<span class="number">1460251672</span>,<span class="number">1460251675</span>,<span class="number">1460251674</span>,<span class="number">1460251677</span>,<span class="number">1460251676</span>,<span class="number">1460251679</span>,<span class="number">1460251678</span>,<span class="number">1460251665</span>,<span class="number">1460251664</span>,<span class="number">1460251667</span>,<span class="number">1460251666</span>,<span class="number">1460251669</span>,<span class="number">1460251668</span>,<span class="number">1460251671</span>,<span class="number">1460251670</span>,<span class="number">1460251689</span>,<span class="number">1460251688</span>,<span class="number">1460251691</span>,<span class="number">1460251690</span>,<span class="number">1460251693</span>,<span class="number">1460251692</span>,<span class="number">1460251695</span>,<span class="number">1460251694</span>,<span class="number">1460251681</span>,<span class="number">1460251680</span>,<span class="number">1460251683</span>,<span class="number">1460251682</span>,<span class="number">1460251685</span>,<span class="number">1460251684</span>,<span class="number">1460251687</span>,<span class="number">1460251686</span>,<span class="number">1460251705</span>,<span class="number">1460251704</span>,<span class="number">1460251707</span>,<span class="number">1460251706</span>,<span class="number">1460251709</span>,<span class="number">1460251708</span>,<span class="number">1460251711</span>,<span class="number">1460251710</span>,<span class="number">1460251697</span>,<span class="number">1460251696</span>,<span class="number">1460251699</span>,<span class="number">1460251698</span>,<span class="number">1460251701</span>,<span class="number">1460251700</span>,<span class="number">1460251703</span>,<span class="number">1460251702</span>,<span class="number">1460251721</span>,<span class="number">1460251720</span>,<span class="number">1460251723</span>,<span class="number">1460251722</span>,<span class="number">1460251725</span>,<span class="number">1460251724</span>,<span class="number">1460251727</span>,<span class="number">1460251726</span>,<span class="number">1460251713</span>,<span class="number">1460251712</span>,<span class="number">1460251715</span>,<span class="number">1460251714</span>,<span class="number">1460251717</span>,<span class="number">1460251716</span>,<span class="number">1460251719</span>,<span class="number">1460251718</span>,<span class="number">1460251737</span>,<span class="number">1460251736</span>,<span class="number">1460251739</span>,<span class="number">1460251738</span>,<span class="number">1460251741</span>,<span class="number">1460251740</span>,<span class="number">1460251743</span>,<span class="number">1460251742</span>,<span class="number">1460251729</span>,<span class="number">1460251728</span>,<span class="number">1460251731</span>,<span class="number">1460251730</span>,<span class="number">1460251733</span>,<span class="number">1460251732</span>,<span class="number">1460251735</span>,<span class="number">1460251734</span>,<span class="number">1460251753</span>,<span class="number">1460251752</span>,<span class="number">1460251755</span>,<span class="number">1460251754</span>,<span class="number">1460251757</span>,<span class="number">1460251756</span>,<span class="number">1460251759</span>,<span class="number">1460251758</span>,<span class="number">1460251745</span>,<span class="number">1460251744</span>,<span class="number">1460251747</span>,<span class="number">1460251746</span>,<span class="number">1460251749</span>,<span class="number">1460251748</span>,<span class="number">1460251751</span>,<span class="number">1460251750</span>,<span class="number">1460251769</span>,<span class="number">1460251768</span>,<span class="number">1460251771</span>,<span class="number">1460251770</span>,<span class="number">1460251773</span>,<span class="number">1460251772</span>,<span class="number">1460251775</span>,<span class="number">1460251774</span>,<span class="number">1460251761</span>,<span class="number">1460251760</span>,<span class="number">1460251763</span>,<span class="number">1460251762</span>,<span class="number">1460251765</span>,<span class="number">1460251764</span>,<span class="number">1460251767</span>,<span class="number">1460251766</span>,<span class="number">1460251785</span>,<span class="number">1460251784</span>,<span class="number">1460251787</span>,<span class="number">1460251786</span>,<span class="number">1460251789</span>,<span class="number">1460251788</span>,<span class="number">1460251791</span>,<span class="number">1460251790</span>,<span class="number">1460251777</span>,<span class="number">1460251776</span>,<span class="number">1460251779</span>,<span class="number">1460251778</span>,<span class="number">1460251781</span>,<span class="number">1460251780</span>,<span class="number">1460251783</span>,<span class="number">1460251782</span>,<span class="number">1460251801</span>,<span class="number">1460251800</span>,<span class="number">1460251803</span>,<span class="number">1460251802</span>,<span class="number">1460251805</span>,<span class="number">1460251804</span>,<span class="number">1460251807</span>,<span class="number">1460251806</span>,<span class="number">1460251793</span>,<span class="number">1460251792</span>,<span class="number">1460251795</span>,<span class="number">1460251794</span>,<span class="number">1460251797</span>,<span class="number">1460251796</span>,<span class="number">1460251799</span>,<span class="number">1460251798</span>,<span class="number">1460251809</span>,<span class="number">1460251808</span>,<span class="number">1460251811</span>,<span class="number">1460251810</span>,<span class="number">1460251813</span>,<span class="number">1460251812</span>,<span class="number">1460251815</span>,<span class="number">1460251814</span>)) </span><br><span class="line"><span class="keyword">AND</span> (`auction_image`.`auction_id` <span class="operator">=</span> <span class="number">319048102</span>) </span><br><span class="line"><span class="keyword">AND</span> (`auction_image`.`status` <span class="operator">=</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>首先我们通过explain和force index来分别看一下走这两个不同索引的执行计划</p><p>首先是老索引auctionId + status， 可以看到使用的是二级索引<br><img src="2.png"></p><p><strong>这条语句的执行过程是这样的：</strong></p><ul><li>按照auction_id&#x3D;319048102 &amp; status &#x3D; 1对该索引进行扫描</li><li>命中一个索引节点，找到该索引下对应的主键id范围(1387次)</li><li>拿着主键id去表里扫描，按行读取，每查询一行，由存储引擎返回到server层，server层使用剩余条件(sku in …)对结果进行过滤</li><li>那么实际一共回表1387次(该商品下有1387个sku)，所以存储引擎和server层交互也是1387次，最终返回693条，filter50%</li></ul><p>再来看新的索引skuId+status，可以看到使用的也是二级索引，不过用上了<em><strong>索引下推</strong></em>， 预估的回表次数只有633次<br><img src="0.png"></p><p><strong>这条语句的执行过程可以描述为：</strong></p><ul><li>按照sku in … 对索引进行扫描(由于最左匹配原则，无法在索引中使用status字段)</li><li>总共命中211个索引条目(skuid数量)， 每个索引节点找到对应的id范围，进行回表</li><li>回表时会使用status进行过滤(索引下推)，这里对结果其实没什么影响</li><li>每次查询返回到server层，对auction_id做判断</li></ul><p>我们先解答为什么MYSQL选择第二种方案，通过普通的explain其实看不太出来优化器的选择逻辑，我们加上type&#x3D;json之后会更清楚一些：</p><p>老索引：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query_block&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;select_id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1664.40&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;table_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auction_image&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ref&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;idx_image_auction_id&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_image_auction_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;used_key_parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;auction_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;status&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;key_length&quot;</span><span class="punctuation">:</span> <span class="string">&quot;11&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ref&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;const&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;const&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;rows_examined_per_scan&quot;</span><span class="punctuation">:</span> <span class="number">1387</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;rows_produced_per_join&quot;</span><span class="punctuation">:</span> <span class="number">693</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="string">&quot;50.00&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1387.00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;138.70&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1664.40&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12M&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;used_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;auction_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sku_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;seller_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;status&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;image_name&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;image_url&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;is_main&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;image_position&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;gmt_create&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;gmt_modified&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;type&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;features&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;feature_cc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;gmt_create_time&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;gmt_modified_time&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;attached_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`lazada_ic_bd_0006`.`auction_image`.`sku_id` in (0,1460251609,1460251608,1460251611,1460251610,1460251613,1460251612,1460251615,1460251614,1460251607,1460251606,1460251625,1460251624,1460251627,1460251626,1460251629,1460251628,1460251631,1460251630,1460251617,1460251616,1460251619,1460251618,1460251621,1460251620,1460251623,1460251622,1460251641,1460251640,1460251643,1460251642,1460251645,1460251644,1460251647,1460251646,1460251633,1460251632,1460251635,1460251634,1460251637,1460251636,1460251639,1460251638,1460251657,1460251656,1460251659,1460251658,1460251661,1460251660,1460251663,1460251662,1460251649,1460251648,1460251651,1460251650,1460251653,1460251652,1460251655,1460251654,1460251673,1460251672,1460251675,1460251674,1460251677,1460251676,1460251679,1460251678,1460251665,1460251664,1460251667,1460251666,1460251669,1460251668,1460251671,1460251670,1460251689,1460251688,1460251691,1460251690,1460251693,1460251692,1460251695,1460251694,1460251681,1460251680,1460251683,1460251682,1460251685,1460251684,1460251687,1460251686,1460251705,1460251704,1460251707,1460251706,1460251709,1460251708,1460251711,1460251710,1460251697,1460251696,1460251699,1460251698,1460251701,1460251700,1460251703,1460251702,1460251721,1460251720,1460251723,1460251722,1460251725,1460251724,1460251727,1460251726,1460251713,1460251712,1460251715,1460251714,1460251717,1460251716,1460251719,1460251718,1460251737,1460251736,1460251739,1460251738,1460251741,1460251740,1460251743,1460251742,1460251729,1460251728,1460251731,1460251730,1460251733,1460251732,1460251735,1460251734,1460251753,1460251752,1460251755,1460251754,1460251757,1460251756,1460251759,1460251758,1460251745,1460251744,1460251747,1460251746,1460251749,1460251748,1460251751,1460251750,1460251769,1460251768,1460251771,1460251770,1460251773,1460251772,1460251775,1460251774,1460251761,1460251760,1460251763,1460251762,1460251765,1460251764,1460251767,1460251766,1460251785,1460251784,1460251787,1460251786,1460251789,1460251788,1460251791,1460251790,1460251777,1460251776,1460251779,1460251778,1460251781,1460251780,1460251783,1460251782,1460251801,1460251800,1460251803,1460251802,1460251805,1460251804,1460251807,1460251806,1460251793,1460251792,1460251795,1460251794,1460251797,1460251796,1460251799,1460251798,1460251809,1460251808,1460251811,1460251810,1460251813,1460251812,1460251815,1460251814))&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>新索引：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query_block&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;select_id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1097.21&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;table_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auction_image&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;access_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;range&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;idx_image_sku_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;idx_image_auction_id&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_image_sku_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;used_key_parts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;sku_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;status&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;key_length&quot;</span><span class="punctuation">:</span> <span class="string">&quot;11&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;rows_examined_per_scan&quot;</span><span class="punctuation">:</span> <span class="number">633</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;rows_produced_per_join&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.01&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;index_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;((`lazada_ic_bd_0006`.`auction_image`.`status` = 1) and (`lazada_ic_bd_0006`.`auction_image`.`sku_id` in (0,1460251609,1460251608,1460251611,1460251610,1460251613,1460251612,1460251615,1460251614,1460251607,1460251606,1460251625,1460251624,1460251627,1460251626,1460251629,1460251628,1460251631,1460251630,1460251617,1460251616,1460251619,1460251618,1460251621,1460251620,1460251623,1460251622,1460251641,1460251640,1460251643,1460251642,1460251645,1460251644,1460251647,1460251646,1460251633,1460251632,1460251635,1460251634,1460251637,1460251636,1460251639,1460251638,1460251657,1460251656,1460251659,1460251658,1460251661,1460251660,1460251663,1460251662,1460251649,1460251648,1460251651,1460251650,1460251653,1460251652,1460251655,1460251654,1460251673,1460251672,1460251675,1460251674,1460251677,1460251676,1460251679,1460251678,1460251665,1460251664,1460251667,1460251666,1460251669,1460251668,1460251671,1460251670,1460251689,1460251688,1460251691,1460251690,1460251693,1460251692,1460251695,1460251694,1460251681,1460251680,1460251683,1460251682,1460251685,1460251684,1460251687,1460251686,1460251705,1460251704,1460251707,1460251706,1460251709,1460251708,1460251711,1460251710,1460251697,1460251696,1460251699,1460251698,1460251701,1460251700,1460251703,1460251702,1460251721,1460251720,1460251723,1460251722,1460251725,1460251724,1460251727,1460251726,1460251713,1460251712,1460251715,1460251714,1460251717,1460251716,1460251719,1460251718,1460251737,1460251736,1460251739,1460251738,1460251741,1460251740,1460251743,1460251742,1460251729,1460251728,1460251731,1460251730,1460251733,1460251732,1460251735,1460251734,1460251753,1460251752,1460251755,1460251754,1460251757,1460251756,1460251759,1460251758,1460251745,1460251744,1460251747,1460251746,1460251749,1460251748,1460251751,1460251750,1460251769,1460251768,1460251771,1460251770,1460251773,1460251772,1460251775,1460251774,1460251761,1460251760,1460251763,1460251762,1460251765,1460251764,1460251767,1460251766,1460251785,1460251784,1460251787,1460251786,1460251789,1460251788,1460251791,1460251790,1460251777,1460251776,1460251779,1460251778,1460251781,1460251780,1460251783,1460251782,1460251801,1460251800,1460251803,1460251802,1460251805,1460251804,1460251807,1460251806,1460251793,1460251792,1460251795,1460251794,1460251797,1460251796,1460251799,1460251798,1460251809,1460251808,1460251811,1460251810,1460251813,1460251812,1460251815,1460251814)))&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1097.20&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.01&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1097.21&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;982&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;used_columns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;auction_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sku_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;seller_id&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;status&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;image_name&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;image_url&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;is_main&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;image_position&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;gmt_create&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;gmt_modified&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;type&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;features&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;feature_cc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;gmt_create_time&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;gmt_modified_time&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;attached_condition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(`lazada_ic_bd_0006`.`auction_image`.`auction_id` = 319048102)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以看到，其中有一个query_cost字段， 这个字段其实就是优化器的决策依据了，我们可以看到新的索引下该值更小，因此优化器选择了新的索引。而这个值的计算公式中其实很大程度上是受rows字段影响(具体的计算方法可以找其他文章搜一下)，也就是说，由于新的索引下优化器预估的rows为600+，小于第一条的1300+，所以选择了新的索引。</p><p><strong>那么问题来了，既然新索引下的rows是600多，看起来回表次数少，性能就是比就索引好呀，为啥还会导致慢SQL呢？</strong></p><p><em><strong>实际上，这里的rows并不准确，这只是MYSQL预估的回表次数，线上这一条SQL真实的回表次数多大7w+次！</strong></em></p><p>是什么导致出现了如此大的偏差？</p><p>为什么走skuId的索引会被MYSQL认为rows是600多呢？</p><p>此时我有了一个猜想：</p><blockquote><p>由于rows是根据统计信息预估的，已知命中的索引节点是211个，最终预估的rows是633，那么可以推测mysql认为每个skuId的索引对应的扫描行数平均是3行</p></blockquote><p>那我们可以看一下不同skuId对应的条目数量的分布来对我的猜想进行验证<br><img src="1.png"></p><p>可以看到，对于除了skuId&#x3D;0以外的所有数据， 一个sku最多也就8行数据(符合整体均值为3的直觉), 而当skuId为0时有7w+行！</p><p><em><strong>这会导致： 当命中skuId&#x3D;0的索引时，会回表7w+次，从而导致性能问题</strong></em></p><p>所以这个问题的根本原因是：<br><em><strong>由于数据倾斜导致的MYSQL优化器的优化策略出现了偏差</strong></em></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这次慢SQL的原因在于，由于MYSQL优化器在对rows进行预测时，使用的是抽样的统计数据，而在这次的case中，数据倾斜非常严重(skuId&#x3D;0有7w+条)，导致当命中skuId&#x3D;0的索引时，MYSQL执行阶段的行为(回表7w+次)和预期结果(600+)相差了十万八千里， 这也是我们刚开始觉得匪夷所思的地方。</p><p>那么这个案例给我们什么启示呢？</p><ul><li>首先，这个例子中的一个设计是用skuId&#x3D;0来表示了一个特殊含义(是否有sku图片), 导致出现了数据的倾斜从而影响到索引性能，对于skuId这样一个很明显会被加到索引中的字段，做这样的设计其实是不太合理的(更合理的设计还是将商品图片和sku图片分开两张表)</li><li>其次，在我们增加一个索引的时候，记得要注意下索引字段的数据分布问题</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.jianshu.com/p/f93b13323058">explain format&#x3D;json 详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/609642080">一起探究MySQL优化器如何选择索引的奥秘</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;这个月某天晚上，IC的同学遇到一个诡异的问题，由于业务侧的开发同学(我们是中台)新增了一个索引，导致线上出现了较多的慢SQL，但是实际上线上</summary>
      
    
    
    
    <category term="后端" scheme="https://blog.cuznlp.cn/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="MYSQL" scheme="https://blog.cuznlp.cn/categories/%E5%90%8E%E7%AB%AF/MYSQL/"/>
    
    
    <category term="MYSQL" scheme="https://blog.cuznlp.cn/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>告别信息过载，15分钟快速搭建rss服务</title>
    <link href="https://blog.cuznlp.cn/2023/08/25/%E5%91%8A%E5%88%AB%E4%BF%A1%E6%81%AF%E8%BF%87%E8%BD%BD%EF%BC%8C15%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BArss%E6%9C%8D%E5%8A%A1/"/>
    <id>https://blog.cuznlp.cn/2023/08/25/%E5%91%8A%E5%88%AB%E4%BF%A1%E6%81%AF%E8%BF%87%E8%BD%BD%EF%BC%8C15%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BArss%E6%9C%8D%E5%8A%A1/</id>
    <published>2023-08-25T03:43:24.000Z</published>
    <updated>2023-08-25T04:02:03.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要rss"><a href="#为什么需要rss" class="headerlink" title="为什么需要rss"></a>为什么需要rss</h1><p><a href="https://sspai.com/post/56391">高效获取信息，你需要这份 RSS 入门指南 - 少数派</a></p><h1 id="参考指南"><a href="#参考指南" class="headerlink" title="参考指南"></a>参考指南</h1><p><a href="https://sspai.com/post/57498">找不到满意的 RSS 服务？你可以自己搭建一个 - 少数派</a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><p>用来管理和启动多个docker容器的工具，可以降低docker应用的部署难度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.25.0/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="comment"># 赋予执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>添加命令到PATH</p><p><a href="https://cloud.tencent.com/developer/article/1097691">linux可执行文件添加到PATH环境变量的方法-腾讯云开发者社区-腾讯云</a></p><h1 id="安装主体"><a href="#安装主体" class="headerlink" title="安装主体"></a>安装主体</h1><p><a href="https://github.com/HenryQW/Awesome-TTRSS">GitHub - HenryQW&#x2F;Awesome-TTRSS: [maintainer wanted] 🐋 Awesome TTRSS, a powerful Dockerised all-in-one RSS solution.</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载docker-compose配置</span></span><br><span class="line">curl -fLo docker-compose.yml https://raw.githubusercontent.com/HenryQW/Awesome-TTRSS/main/docker-compose.yml</span><br></pre></td></tr></table></figure><p>修改配置文件</p><ul><li>将 PostgreSQL 数据库的默认密码进行修改。暴露在公网的数据库使用默认密码非常危险。</li><li>将 Tiny Tiny RSS 服务的部署网址修改为我们实际的部署网址</li><li>注意，如果你的部署 URL 包含端口（默认部署端口为 181 端口），那么这里的 URL 也需要加上端口号，格式为 {网址}:{端口}不过不必担心，如果你这里的 URL 配置不正确，那么访问 Tiny Tiny RSS 的时候，Tiny Tiny RSS 会提醒你修改这里的值为正确的 URL，按照提醒进行配置即可</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在该目录下运行docker-compose， 启动Tiny Tiny RSS服务</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"><span class="comment"># 查看服务是否启动</span></span><br><span class="line">docker -ps </span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>上面内容表示我们开启了四个 Docker 容器，分别是：</p><ul><li>Tiny Tiny RSS 本身，监听端口为 <code>0.0.0.0:181 → 80</code>，同时暴露给外网</li><li>PostgreSQL 数据库服务</li><li>Mercury 全文抓取服务</li><li>OpenCC 简体、繁体中文转换服务</li></ul><p>如果发现问题，修改 docker-compose 的配置文件后，需要执行下面的命令重启 Docker 容器们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 关闭 Docker 容器们</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除已停止的 Docker 容器</span></span><br><span class="line">docker-compose <span class="built_in">rm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ……</span></span><br><span class="line"><span class="comment"># 修改 docker-compose 配置文件</span></span><br><span class="line"><span class="comment"># ……</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次开启 Docker 服务</span></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>nginx添加反向代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name ttrss.cuznlp.cn;</span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass http://localhost:181;</span><br><span class="line">    &#125;</span><br><span class="line">    access_log  /www/wwwlogs/access.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用Tiny-Tiny-RSS"><a href="#使用Tiny-Tiny-RSS" class="headerlink" title="使用Tiny Tiny RSS"></a>使用Tiny Tiny RSS</h1><p>默认账号： admin</p><p>密码： password</p><p>其他的一些插件配置自己搜一下</p><h2 id="rss订阅源生成器"><a href="#rss订阅源生成器" class="headerlink" title="rss订阅源生成器"></a>rss订阅源生成器</h2><p><a href="https://docs.rsshub.app/">介绍 | RSSHub</a></p><p><a href="https://diygod.me/ohmyrss">我有特别的 RSS 使用技巧 - DIYgod</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么需要rss&quot;&gt;&lt;a href=&quot;#为什么需要rss&quot; class=&quot;headerlink&quot; title=&quot;为什么需要rss&quot;&gt;&lt;/a&gt;为什么需要rss&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://sspai.com/post/56391&quot;&gt;高效获取信息，</summary>
      
    
    
    
    <category term="效率" scheme="https://blog.cuznlp.cn/categories/%E6%95%88%E7%8E%87/"/>
    
    
    <category term="建站" scheme="https://blog.cuznlp.cn/tags/%E5%BB%BA%E7%AB%99/"/>
    
    <category term="效率" scheme="https://blog.cuznlp.cn/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>搞懂这些，mysql就可以啦</title>
    <link href="https://blog.cuznlp.cn/2023/08/24/%E6%90%9E%E6%87%82%E8%BF%99%E4%BA%9B%EF%BC%8Cmysql%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%95%A6/"/>
    <id>https://blog.cuznlp.cn/2023/08/24/%E6%90%9E%E6%87%82%E8%BF%99%E4%BA%9B%EF%BC%8Cmysql%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%95%A6/</id>
    <published>2023-08-24T14:26:24.000Z</published>
    <updated>2023-08-29T02:30:03.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://xiaolincoding.com/">原文链接</a> by 小林coding，对我认为比较重要的点进行了摘录，丢失了大量细节，原文更加深入、细致和全面 </p></blockquote><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="执行一条SQL发生了什么"><a href="#执行一条SQL发生了什么" class="headerlink" title="执行一条SQL发生了什么"></a>执行一条SQL发生了什么</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png"></p><ul><li>连接器：客户端和server建立TCP连接<ul><li>一般来说使用长连接，从而节省建立和断开连接的开销</li><li>但是长连接可能导致内存占用过多(因为连接释放时才会释放对象，如果长连接累计过多，会导致MYSQL服务占用内存过大导致被系统杀掉重启)<ul><li>如何解决？<ul><li>定期断开长连接</li><li>客户端调用api主动重置连接</li></ul></li></ul></li></ul></li><li>查询缓存：比较鸡肋，只要表级别有任何更新就会失效，8.0之后就删掉这个功能了</li><li>解析器：词法语法分析</li><li>执行器<ul><li>prepare<ul><li>检查语句中的表或者字段是否存在</li><li>将select * 转变为实际的列</li></ul></li><li>优化器<ul><li>确定执行计划</li></ul></li><li>执行，和存储引擎交互<ul><li>按行从存储引擎读取，然后交给server判断，满足要求就返回给客户端，不断循环</li><li>索引下推(减少二级索引的回表操作，可以用到原本无法走到的索引字段来进行索引节点的过滤)</li></ul></li></ul></li></ul><h2 id="一行记录是怎么存储的"><a href="#一行记录是怎么存储的" class="headerlink" title="一行记录是怎么存储的"></a>一行记录是怎么存储的</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png"></p><ul><li>额外信息<ul><li>变长字段长度列表<ul><li>记录varchar列的长度</li></ul></li><li>NULL值列表<ul><li>记录哪些列是null值</li><li>至少1字节，使用整数字节，一列使用一位，例如如果不到8个字段是null，一个字节就够，9个字段的话，要两个字节</li></ul></li><li>记录头信息<ul><li>delete_mask: 标识该条目是否被删除(mysql在调用delete删除数据的时候，不是真正的删除记录，而是标识该字段)</li><li>next_record: 下一条记录的位置(记录和记录之间是通过链表组织的)</li><li>record_type: 标识当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li></ul></li></ul></li><li>真实记录<ul><li>三个隐藏字段<ul><li>row_id  6个字节<ul><li>如果建表的时候使用了主键或者uk，那么就没有row_id了。如果没有上面两种情况，InnoDB会给记录添加row_id隐藏字段。</li></ul></li><li>trx_id  6个字节<ul><li>事务id，表示该数据是由哪个事务生成的。trx是必需的</li></ul></li><li>roll_pointer  7个字节<ul><li>记录上一个版本的指针， 和trx_id一起服务于mvcc</li></ul></li></ul></li></ul></li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%8F%90%E7%BA%B2.png" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/索引/索引提纲.png"></p><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><aside>💡 非叶子节点只放索引，叶子节点才放数据(或者主键id)，每个节点里的数据是按照主键顺序存放。每一层父节点的索引值都会出现在下层子节点的索引值中。因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向列表</aside><p>主键索引</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/btree.drawio.png" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/索引/btree.drawio.png"></p><p>二级索引：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95btree.drawio.png" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/索引/二级索引btree.drawio.png"></p><aside>💡 为什么使用B+树？</aside><p><a href="https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html#%E6%80%8E%E6%A0%B7%E7%9A%84%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E5%A5%BD%E7%9A%84">为什么 MySQL 采用 B+ 树作为索引？</a></p><p>B+树存储千万级的数据只需要3-4层高度就可以满足，这意味着从千万级的表查询目标数据最多需要3-4次磁盘IO，所以B+树相比于B树和二叉树来说，最大的优势在于查询效率高，因为即使在数据量很大的情况，查询一个数据的磁盘IO依然维持在3-4次</p><ul><li>B+树 vs B树</li><li>B树的非叶子节点也要存储数据，导致单个节点的数据量更大，因此在相同的磁盘IO次数下，B+树能够查询更多的节点</li><li>B+树的叶子节点为双链表，适合与MYSQL的范围查找，B树做不到这一点</li><li>vs 二叉树</li><li>B+树一般一个节点可以有100+子节点，而二叉树只能有两个，导致深度太深，查询效率低</li></ul><h2 id="联合索引和最左匹配"><a href="#联合索引和最左匹配" class="headerlink" title="联合索引和最左匹配"></a>联合索引和最左匹配</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.drawio.png" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/索引/联合索引.drawio.png"></p><p><strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li><li>where a&#x3D;1 and b&#x3D;2；</li></ul><p><em><strong>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</strong></em></p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b&#x3D;2；</li><li>where c&#x3D;3；</li><li>where b&#x3D;2 and c&#x3D;3；</li></ul><p>上面这些查询条件之所以会失效，是因为<code>(a, b, c)</code> 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</p><p>当你的查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化。</p><h2 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h2><p>建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p><p>因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描。</p><h2 id="filesort"><a href="#filesort" class="headerlink" title="filesort"></a>filesort</h2><p>这里出一个题目，针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？</p><p><code>select * from order where status = 1 order by create_time asc</code></p><p>有的同学会认为，单独给 status 建立一个索引就可以了。</p><p>但是更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。</p><p>因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。</p><p>所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。</p><h2 id="主键为什么最好自增"><a href="#主键为什么最好自增" class="headerlink" title="主键为什么最好自增"></a>主键为什么最好自增</h2><p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p><p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p><h2 id="索引最好设置为not-null"><a href="#索引最好设置为not-null" class="headerlink" title="索引最好设置为not null"></a>索引最好设置为not null</h2><p>索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</p><h2 id="count-1-和count-哪个性能更好"><a href="#count-1-和count-哪个性能更好" class="headerlink" title="count(1)和count(*)哪个性能更好"></a>count(1)和count(*)哪个性能更好</h2><p>count(1) &#x3D; count(*) &gt; count(主键) &gt; count(其他字段)</p><p>count主键在遍历索引的时候会读取id值判断是不是null，而count 1和count * 不会，所以这两个比count主键的性能稍微好一点</p><p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。</p><p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p><p>再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h2><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。<ul><li><strong>通过undo log来保证</strong></li></ul></li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。<ul><li><strong>通过其他三个特性来保证</strong></li></ul></li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。<ul><li><strong>通过MVCC或锁机制来保证</strong></li></ul></li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<ul><li><strong>通过redo log来保证</strong></li></ul></li></ul><h2 id="事务隔离级别和对应问题"><a href="#事务隔离级别和对应问题" class="headerlink" title="事务隔离级别和对应问题"></a>事务隔离级别和对应问题</h2><ul><li><strong>读未提交（<em>read uncommitted</em>）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；<ul><li>导致脏读</li></ul></li><li><strong>读提交（<em>read committed</em>）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；<ul><li>导致不可重复读</li></ul></li><li><strong>可重复读（<em>repeatable read</em>）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；<ul><li>导致幻读</li></ul></li><li><strong>串行化（<em>serializable</em> ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p><strong>MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。</strong></p><p>解决的方法：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h2 id="read-view和mvcc"><a href="#read-view和mvcc" class="headerlink" title="read view和mvcc"></a>read view和mvcc</h2><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/事务隔离/readview结构.drawio.png"></p><p>Read View 有四个重要的字段：</p><ul><li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li><li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li></ul><p>两个隐藏列：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png" alt="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png"></p><ul><li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li><li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ul><p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png"></p><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id 值在 Read View 的 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，需要判断 trx_id 是否在 m_ids 列表中：<ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p><h2 id="可重复读是如何工作的"><a href="#可重复读是如何工作的" class="headerlink" title="可重复读是如何工作的"></a>可重复读是如何工作的</h2><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p><p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE-new.png" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE-new.png"></p><p>事务 A 和 事务 B 的 Read View 具体内容如下：</p><ul><li>在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。</li><li>在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，<strong>活跃的事务 id 中最小的事务 id 是事务 A</strong>，下一个事务 id 应该是 53。</li></ul><p>接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：</p><ul><li>事务 B 读取小林的账户余额记录，读到余额是 100 万；</li><li>事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额还是 100 万；</li><li>事务 A 提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；</li></ul><p>接下来，跟大家具体分析下。</p><p>事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时<strong>发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的</strong>，也就是事务 B 可以获取到这条记录。</p><p>接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong>，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE2.png" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE2.png"></p><p>你可以在上图的「记录的字段」看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id &#x3D; 51）。</p><p>然后事务 B 第二次去读取该记录，<strong>发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录</strong>，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p>最后，当事物 A 提交事务后，<strong>由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将小林余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录</strong>。</p><p>就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="MYSQL有哪些锁"><a href="#MYSQL有哪些锁" class="headerlink" title="MYSQL有哪些锁"></a>MYSQL有哪些锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a><strong>全局锁</strong></h3><ul><li><code>flush tables with read lock</code></li><li>释放锁：<code>unlock tables</code></li><li>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</li><li>备份时有没有别的解法<ul><li>如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</li><li>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</li><li>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</li><li>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</li></ul></li></ul><hr><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a><strong>表级锁</strong></h3><p><strong>表锁</strong></p><ul><li>基本不用，影响并发</li></ul><p><strong>元数据锁(MDL)</strong></p><ul><li>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：<ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul></li><li>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</li></ul><aside>💡 长事务导致的线程打满</aside><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p><ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li><li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li><li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li></ol><p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p><blockquote><p>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</p></blockquote><p>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p><p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p><p><strong>意向锁</strong></p><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li><li>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</li></ul><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（<em>lock tables … read</em>）和独占表锁（<em>lock tables … write</em>）发生冲突。</strong></p><p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p><p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><hr><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a><strong>行级锁</strong></h3><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；目的是为了解决可重复读隔离级别下幻读的现象。</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><h2 id="MYSQL如何加锁"><a href="#MYSQL如何加锁" class="headerlink" title="MYSQL如何加锁"></a>MYSQL如何加锁</h2><p><strong>加锁的对象是索引，加锁的基本单位是 next-key lock</strong></p><p><a href="https://xiaolincoding.com/mysql/lock/how_to_lock.html#%E4%BB%80%E4%B9%88-sql-%E8%AF%AD%E5%8F%A5%E4%BC%9A%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81">MySQL 是怎么加锁的？</a></p><h2 id="为什么update一定要带索引"><a href="#为什么update一定要带索引" class="headerlink" title="为什么update一定要带索引"></a>为什么update一定要带索引</h2><p><a href="https://xiaolincoding.com/mysql/lock/update_index.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E8%BF%99%E7%A7%8D%E7%9A%84%E4%BA%8B%E6%95%85">update 没加索引会锁全表？</a></p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="MYSQL3种日志"><a href="#MYSQL3种日志" class="headerlink" title="MYSQL3种日志"></a>MYSQL3种日志</h2><ul><li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li><li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li><li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li></ul><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a><strong>undo log</strong></h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/回滚事务.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0"></p><p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：</p><ul><li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li><li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</li></ul><p>版本链如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E7%89%88%E6%9C%AC%E9%93%BE.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E7%89%88%E6%9C%AC%E9%93%BE.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0"></p><p>因此，undo log 两大作用：</p><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><p><strong>TIP</strong></p><p>很多人疑问 undo log 是如何刷盘（持久化到磁盘）的？</p><p>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。</p><p>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。</p><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/缓冲池.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0"></p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpool%E5%86%85%E5%AE%B9.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpool内容.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0"></p><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p><p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p><h2 id="redo-log-和-WAL"><a href="#redo-log-和-WAL" class="headerlink" title="redo log 和 WAL"></a>redo log 和 WAL</h2><p>Buffer Pool提高了读写效率，但是Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p><p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p><p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p><p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/wal.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/wal.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0"></p><p>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p><p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p><blockquote><p>redo log 和 undo log 区别在哪？</p></blockquote><p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p><ul><li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li><li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li></ul><p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过</p><blockquote><p>redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</p></blockquote><p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p><p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p><p>针对「顺序写」为什么比「随机写」更快这个问题，可以比喻为你有一个本子，按照顺序一页一页写肯定比写一个字都要找到对应页写快得多。</p><p>可以说这是 WAL 技术的另外一个优点：<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。</p><p>至此， 针对为什么需要 redo log 这个问题我们有两个答案：</p><ul><li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li></ul><h2 id="redo-log什么时候刷盘"><a href="#redo-log什么时候刷盘" class="headerlink" title="redo log什么时候刷盘"></a>redo log什么时候刷盘</h2><p>主要有下面几个时机：</p><ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。</li></ul><h2 id="redo-log会写满吗"><a href="#redo-log会写满吗" class="headerlink" title="redo log会写满吗"></a>redo log会写满吗</h2><p>重做日志文件组是以<strong>循环写</strong>的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。</p><h2 id="redo-log和binlog的区别"><a href="#redo-log和binlog的区别" class="headerlink" title="redo log和binlog的区别"></a>redo log和binlog的区别</h2><p>这两个日志有四个区别。</p><p><em>1、适用对象不同：</em></p><ul><li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li><li>redo log 是 Innodb 存储引擎实现的日志；</li></ul><p><em>2、文件格式不同：</em></p><ul><li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li><li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li><li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li></ul></li><li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li></ul><p><em>3、写入方式不同：</em></p><ul><li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li><li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li></ul><p><em>4、用途不同：</em></p><ul><li>binlog 用于备份恢复、主从复制；</li><li>redo log 用于掉电等故障恢复。</li></ul><blockquote><p>如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？</p></blockquote><p>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。</p><p>因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。</p><p>binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。</p><h2 id="mysql主从复制怎么实现的"><a href="#mysql主从复制怎么实现的" class="headerlink" title="mysql主从复制怎么实现的"></a>mysql主从复制怎么实现的</h2><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p><p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0"></p><p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p><ul><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li><li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li><li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li></ul><p>具体详细过程如下：</p><ul><li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li><li>从库会创建一个专门的 I&#x2F;O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li><li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li></ul><p>在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。</p><h2 id="一条update语句的执行过程"><a href="#一条update语句的执行过程" class="headerlink" title="一条update语句的执行过程"></a>一条update语句的执行过程</h2><p>具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程如下:</p><ol><li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：<ul><li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li></ul></li><li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul><li>如果一样的话就不进行后续更新流程；</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li></ul></li><li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li><li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li><li>至此，一条记录更新完了。</li><li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li><li>事务提交，剩下的就是「两阶段提交」的事情了，接下来就讲这个。</li></ol><h2 id="为什么要两阶段提交"><a href="#为什么要两阶段提交" class="headerlink" title="为什么要两阶段提交"></a>为什么要两阶段提交</h2><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p><p>举个例子，假设 id &#x3D; 1 这行数据的字段 name 的值原本是 ‘jay’，然后执行 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 如果在持久化 redo log 和 binlog 两个日志的过程中，出现了半成功状态，那么就有两种情况：</p><ul><li><strong>如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入</strong>。MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id &#x3D; 1 这行数据的 name 字段恢复到新值 xiaolin，但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致性；</li><li><strong>如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入</strong>。由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id &#x3D; 1 这行数据的 name 字段还是旧值 jay，而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 xiaolin，与主库的值不一致性；</li></ul><p>可以看到，在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</p><p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong>，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p><p><strong>两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」</strong>，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。注意，不要把提交（Commit）阶段和 commit 语句混淆了，commit 语句执行的时候，会包含提交（Commit）阶段。</p><p>举个拳击比赛的例子，两位拳击手（参与者）开始比赛之前，裁判（协调者）会在中间确认两位拳击手的状态，类似于问你准备好了吗？</p><ul><li><strong>准备阶段</strong>：裁判（协调者）会依次询问两位拳击手（参与者）是否准备好了，然后拳击手听到后做出应答，如果觉得自己准备好了，就会跟裁判说准备好了；如果没有自己还没有准备好（比如拳套还没有带好），就会跟裁判说还没准备好。</li><li><strong>提交阶段</strong>：如果两位拳击手（参与者）都回答准备好了，裁判（协调者）宣布比赛正式开始，两位拳击手就可以直接开打；如果任何一位拳击手（参与者）回答没有准备好，裁判（协调者）会宣布比赛暂停，对应事务中的回滚操作。</li></ul><h2 id="两阶段提交的过程是怎样的？"><a href="#两阶段提交的过程是怎样的？" class="headerlink" title="两阶段提交的过程是怎样的？"></a><strong>两阶段提交的过程是怎样的？</strong></h2><p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了<strong>内部 XA 事务</strong>（是的，也有外部 XA 事务，跟本文不太相关，我就不介绍了），内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。</p><p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong>，如下图：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0"></p><p>从图中可看出，事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong>，具体如下：</p><ul><li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit &#x3D; 1 的作用）；</li><li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog &#x3D; 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li></ul><h2 id="异常重启会出现什么现象？"><a href="#异常重启会出现什么现象？" class="headerlink" title="异常重启会出现什么现象？"></a><strong>异常重启会出现什么现象？</strong></h2><p>我们来看看在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象？下图中有时刻 A 和时刻 B 都有可能发生崩溃：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/how_update/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0"></p><p>不管是时刻 A（redo log 已经写入磁盘， binlog 还没写入磁盘），还是时刻 B （redo log 和 binlog 都已经写入磁盘，还没写入 commit 标识）崩溃，<strong>此时的 redo log 都处于 prepare 状态</strong>。</p><p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：</p><ul><li><strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。对应时刻 A 崩溃恢复的情况。</li><li><strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</strong>。对应时刻 B 崩溃恢复的情况。</li></ul><p>可以看到，<strong>对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID</strong>，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。</p><p>所以说，<strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong>，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://xiaolincoding.com/&quot;&gt;原文链接&lt;/a&gt; by 小林coding，对我认为比较重要的点进行了摘录，丢失了大量细节，原文更加深入、细致和全面 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;基础</summary>
      
    
    
    
    <category term="面试" scheme="https://blog.cuznlp.cn/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="后端" scheme="https://blog.cuznlp.cn/categories/%E9%9D%A2%E8%AF%95/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="MYSQL" scheme="https://blog.cuznlp.cn/tags/MYSQL/"/>
    
    <category term="面试" scheme="https://blog.cuznlp.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>15分钟快速搭建hexo个人博客</title>
    <link href="https://blog.cuznlp.cn/2023/08/24/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAhexo/"/>
    <id>https://blog.cuznlp.cn/2023/08/24/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAhexo/</id>
    <published>2023-08-24T11:49:58.000Z</published>
    <updated>2023-08-29T02:23:26.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.cn/post/6978377036645531662">Mac OS上搭建Hexo博客流程  - 掘金</a></p><p><a href="https://cloud.tencent.com/developer/article/1964349">个人域名绑定</a></p><p><a href="https://stackoverflow.com/questions/68775869/message-support-for-password-authentication-was-removed">github鉴权问题</a></p><p><img src="hexo_auth.png" alt="github鉴权问题"></p><p><a href="https://zhuanlan.zhihu.com/p/542101567">图片不展示问题</a></p><p><a href="https://zhuanlan.zhihu.com/p/344927945">seo优化</a></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo n  新增文章</span><br><span class="line">hexo clean 清空缓存</span><br><span class="line">hexo g 重新生成静态文件</span><br><span class="line">hexo s 本地启动</span><br><span class="line">hexo d 远端部署</span><br></pre></td></tr></table></figure><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p><a href="https://butterfly.js.org/">Butterfly</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6978377036645531662&quot;&gt;Mac OS上搭建</summary>
      
    
    
    
    <category term="效率" scheme="https://blog.cuznlp.cn/categories/%E6%95%88%E7%8E%87/"/>
    
    
    <category term="建站" scheme="https://blog.cuznlp.cn/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>树，掌握这些，就可以啦</title>
    <link href="https://blog.cuznlp.cn/2022/06/08/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%A0%91/"/>
    <id>https://blog.cuznlp.cn/2022/06/08/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%A0%91/</id>
    <published>2022-06-08T13:51:46.000Z</published>
    <updated>2023-08-27T13:56:52.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="二叉树分类"><a href="#二叉树分类" class="headerlink" title="二叉树分类"></a>二叉树分类</h2><ul><li>完全二叉树</li><li>满二叉树</li><li>二叉搜索树</li><li>平衡二叉树</li><li>红黑树</li></ul><h2 id="二叉树的表示"><a href="#二叉树的表示" class="headerlink" title="二叉树的表示"></a>二叉树的表示</h2><ul><li>链表存储</li><li>数组存储。非常适合完全二叉树</li></ul><h1 id="一个中心"><a href="#一个中心" class="headerlink" title="一个中心"></a>一个中心</h1><p>树的遍历。</p><p>遍历不是目的，遍历是为了更好地做处理，这里的处理包括搜索，修改树等。树虽然只能从根开始访问，但是我们可以选择在访问完毕回来的时候做处理，还是在访问回来之前做处理，这两种不同的方式就是后序遍历和先序遍历。</p><h2 id="前序遍历-根-左-右"><a href="#前序遍历-根-左-右" class="headerlink" title="前序遍历 根-左-右"></a>前序遍历 根-左-右</h2><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历 easy</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历-递归</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    result.addAll(preorderTraversal(root.left));</span><br><span class="line">    result.addAll(preorderTraversal(root.right));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/70817ffb97ad">迭代法这个最浅显易懂，猛戳这里</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">preorderTraversalIter</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(pop.val);</span><br><span class="line">        <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(pop.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(pop.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-左-根-右"><a href="#中序遍历-左-根-右" class="headerlink" title="中序遍历 左-根-右"></a>中序遍历 左-根-右</h2><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 easy</a><br>迭代算法图示</p><ol><li>根节点入栈</li><li>判断有没有左节点，如果有，则入栈，直到叶子节点.  此时栈中保存的就是所有的左节点和根节点。</li><li>出栈，判断有没有右节点，有则入栈，继续执行 2</li></ol><p><img src="assets/img/posts/20220608/inorder.gif"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">递归算法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        result.addAll(inorderTraversal(root.left));</span><br><span class="line">    &#125;</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        result.addAll(inorderTraversal(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">迭代算法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">inOrderTraversalByStack</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历-左-右-根"><a href="#后序遍历-左-右-根" class="headerlink" title="后序遍历 左-右-根"></a>后序遍历 左-右-根</h2><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a><br>递归简单，就不列在这里了<br><em><strong>硬用迭代法写的话比较难写， 思路是将前序遍历的中-左-右里左右节点顺序调一下， 变成中-右-左， 然后将结果整个反转，变成左-右-中</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p><h3 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h3><p><em><strong>利用队列，每一层完成后添加一个null或者特殊节点做分割</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">10000</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.val != <span class="number">10000</span>) &#123;</span><br><span class="line">            subList.add(cur);</span><br><span class="line">            cur = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(subList.stream().map(node -&gt; node.val).collect(Collectors.toList()));</span><br><span class="line">        <span class="keyword">for</span> (TreeNode treeNode : subList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(treeNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(treeNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">10000</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/die-dai-di-gui-duo-tu-yan-shi-102er-cha-shu-de-cen/">题解</a><br>dfs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderRecursive</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, TreeNode root, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.size() == i) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    result.get(i).add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(i + <span class="number">1</span>, root.left, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        dfs(i + <span class="number">1</span>, root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 easy</a><br>写个递归就行了，比较简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + (Math.max(leftDepth, rightDepth));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II middle</a><br><em><strong>就是树的BFS</strong></em></p><h1 id="两个基本点"><a href="#两个基本点" class="headerlink" title="两个基本点"></a>两个基本点</h1><p><em><strong>DFS(深度优先)&amp;BFS(广度优先)</strong></em></p><p>DFS 细分为前中后序遍历， BFS 细分为带层的和不带层的。</p><p>DFS 适合做一些暴力枚举的题目，DFS 如果借助函数调用栈，则可以轻松地使用递归来实现。</p><p><em><strong>BFS 不是 层次遍历</strong></em><br>而 BFS 适合求最短距离，这个和层次遍历是不一样的，很多人搞混。这里强调一下，层次遍历和 BFS 是完全不一样的东西。</p><p>层次遍历就是一层层遍历树，按照树的层次顺序进行访问。</p><p>BFS 的核心在于求最短问题时候可以提前终止，这才是它的核心价值，层次遍历是一种不需要提前终止的 BFS 的副产物。这个提前终止不同于 DFS 的剪枝的提前终止，而是找到最近目标的提前终止。比如我要找距离最近的目标节点，BFS 找到目标节点就可以直接返回。而 DFS 要穷举所有可能才能找到最近的，这才是 BFS 的核心价值。实际上，我们也可以使用 DFS 实现层次遍历的效果，借助于递归，代码甚至会更简单。</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止，属于盲目搜索。</p><p>对于树的题目，我们基本上都可以使用 DFS 来解决，甚至我们可以基于 DFS 来做层次遍历，而且由于 DFS 可以基于递归去做，因此算法会更简洁。 在对性能有很高要求的场合，我建议你使用迭代，否则尽量使用递归，不仅写起来简单快速，还不容易出错。</p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>BFS 也是图论中算法的一种，不同于 DFS， <em><strong>BFS 采用横向搜索的方式，在数据结构上通常采用队列结构。 注意，DFS 我们借助的是栈来完成，而这里借助的是队列。</strong></em></p><p>BFS 比较适合找最短距离&#x2F;路径和某一个距离的目标。比如给定一个二叉树，在树的最后一行找到最左边的值。 ，此题是力扣 513 的原题。这不就是求距离根节点最远距离的目标么？ 一个 BFS 模板就解决了。</p><p><strong>BFS算法模板</strong><br>标记层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">bfs</span><span class="params">(k)</span>:</span><br><span class="line">        # 使用双端队列，而不是数组。因为数组从头部删除元素的时间复杂度为 N，双端队列的底层实现其实是链表。</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        # 记录层数</span><br><span class="line">        steps = <span class="number">0</span></span><br><span class="line">        # 需要返回的节点</span><br><span class="line">        ans = []</span><br><span class="line">        # 队列不空，生命不止！</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = len(queue)</span><br><span class="line">            # 遍历当前层的所有节点</span><br><span class="line">            <span class="keyword">for</span> _ in <span class="title function_">range</span><span class="params">(size)</span>:</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> (step == k) ans.append(node)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">            # 遍历完当前层所有的节点后 steps + <span class="number">1</span></span><br><span class="line">            steps += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>不标记层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">bfs</span><span class="params">(k)</span>:</span><br><span class="line">        # 使用双端队列，而不是数组。因为数组从头部删除元素的时间复杂度为 N，双端队列的底层实现其实是链表。</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        # 队列不空，生命不止！</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            # 由于没有记录 steps，因此我们肯定是不需要根据层的信息去判断的。否则就用带层的模板了。</span><br><span class="line">            <span class="keyword">if</span> (node 是我们要找到的) <span class="keyword">return</span> node</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="三种题型"><a href="#三种题型" class="headerlink" title="三种题型"></a>三种题型</h1><h2 id="搜索类"><a href="#搜索类" class="headerlink" title="搜索类"></a>搜索类</h2><p>搜索类的题目是树的题目的绝对大头。而搜索类只有两种解法，那就是 DFS 和 BFS，下面分别介绍。</p><p>几乎所有的搜索类题目都可以方便地使用递归来实现，关于递归的技巧会在七个技巧中的单&#x2F;双递归部分讲解。还有一小部分使用递归不好实现，我们可以使用 BFS，借助队列轻松实现，比如最经典的是求二叉树任意两点的距离，树的距离其实就是最短距离，因此可以用 BFS 模板解决。这也是为啥我说DFS 和 BFS是树的题目的两个基本点的原因。</p><p>所有搜索类的题目只要把握三个核心点，即开始点，结束点 和 目标即可。</p><p><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径 middle</a></p><p><em><strong>回溯</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        recur(root, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 我理解这里面remove就是回溯的核心</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(TreeNode root, <span class="type">int</span> tar)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.add(root.val);</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextTar</span> <span class="operator">=</span> tar - root.val;</span><br><span class="line">    <span class="keyword">if</span> (nextTar == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        path.removeLast();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recur(root.left, nextTar);</span><br><span class="line">    recur(root.right, nextTar);</span><br><span class="line">    path.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/">1372. 二叉树中的最长交错路径 middle</a></p><p><em><strong>尚未完全掌握</strong></em></p><h2 id="构建类"><a href="#构建类" class="headerlink" title="构建类"></a>构建类</h2><h3 id="普通二叉树构建"><a href="#普通二叉树构建" class="headerlink" title="普通二叉树构建"></a>普通二叉树构建</h3><h4 id="DFS遍历构造原始二叉树"><a href="#DFS遍历构造原始二叉树" class="headerlink" title="DFS遍历构造原始二叉树"></a>DFS遍历构造原始二叉树</h4><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树 middle</a></p><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">首先根据 preorder 找到根节点是 <span class="number">3</span></span><br><span class="line"></span><br><span class="line">然后根据根节点将 inorder 分成左子树和右子树</span><br><span class="line">左子树</span><br><span class="line">inorder [<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">右子树</span><br><span class="line">inorder [<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">把相应的前序遍历的数组也加进来</span><br><span class="line">左子树</span><br><span class="line">preorder[<span class="number">9</span>]</span><br><span class="line">inorder [<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">右子树</span><br><span class="line">preorder[<span class="number">20</span> <span class="number">15</span> <span class="number">7</span>]</span><br><span class="line">inorder [<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题</span><br><span class="line">然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 <span class="literal">null</span> 即可</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">    inOrderIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">        inOrderIndexMap.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildTree(preorder, inorder, <span class="number">0</span>, n-<span class="number">1</span>, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preOrder, <span class="type">int</span>[] inOrder, <span class="type">int</span> preOrderStart, <span class="type">int</span> preOrderEnd, <span class="type">int</span> inOrderStart, <span class="type">int</span> inOrderEnd)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preOrderStart &gt; preOrderEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">preOrderRoot</span> <span class="operator">=</span> preOrderStart;</span><br><span class="line">    <span class="type">int</span> <span class="variable">inOrderRoot</span> <span class="operator">=</span> inOrderIndexMap.get(preOrder[preOrderRoot]);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preOrder[preOrderRoot]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftTreeSize</span> <span class="operator">=</span> inOrderRoot - inOrderStart;</span><br><span class="line"></span><br><span class="line">    root.left = buildTree(preOrder, inOrder, preOrderStart + <span class="number">1</span>, preOrderStart + leftTreeSize, inOrderStart, inOrderRoot - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(preOrder, inOrder, preOrderStart + leftTreeSize + <span class="number">1</span>, preOrderEnd, inOrderRoot + <span class="number">1</span>, inOrderEnd);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 middle</a></p><p><em><strong>跟上面那题解法基本差不多，要画图和调试</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder == <span class="literal">null</span> || postorder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        inOrderIndexMap.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buildTree(inorder, postorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inOrder, <span class="type">int</span>[] postOrder, <span class="type">int</span> inOrderStart, <span class="type">int</span> inOrderEnd, <span class="type">int</span> postOrderStart, <span class="type">int</span> postOrderEnd)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (postOrderStart &gt; postOrderEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (postOrderEnd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postOrder[postOrderEnd]);</span><br><span class="line">    <span class="comment">// 从inOrder里面拆除左子树和右子树</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">rootIndexInInOrder</span> <span class="operator">=</span> inOrderIndexMap.get(postOrder[postOrderEnd]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftCnt</span> <span class="operator">=</span> rootIndexInInOrder - inOrderStart;</span><br><span class="line"></span><br><span class="line">    root.left = buildTree(inOrder, postOrder, inOrderStart, inOrderStart + leftCnt - <span class="number">1</span>, postOrderStart, postOrderStart + leftCnt - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(inOrder, postOrder, rootIndexInInOrder + <span class="number">1</span>, inOrderEnd, postOrderStart + leftCnt, postOrderEnd - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树 middle</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; postorder.length; i++) &#123;</span><br><span class="line">        postIndexMap.put(postorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> constructFromPrePost(preorder, postorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder,</span></span><br><span class="line"><span class="params">                                            <span class="type">int</span> preStartIndex, <span class="type">int</span> preEndIndex,</span></span><br><span class="line"><span class="params">                                            <span class="type">int</span> postStartIndex, <span class="type">int</span> postEndIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (postStartIndex &gt; postEndIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preStartIndex]);</span><br><span class="line">    <span class="keyword">if</span> (preStartIndex == preEndIndex || postStartIndex == postEndIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> preorder[preStartIndex + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftCnt</span> <span class="operator">=</span> postIndexMap.get(left) - postStartIndex + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    root.left = constructFromPrePost(preorder, postorder,</span><br><span class="line">            preStartIndex + <span class="number">1</span>, preStartIndex + leftCnt, postStartIndex, postStartIndex + leftCnt - <span class="number">1</span>);</span><br><span class="line">    root.right = constructFromPrePost(preorder, postorder,</span><br><span class="line">            preStartIndex + leftCnt + <span class="number">1</span>, preEndIndex, postStartIndex + leftCnt, postEndIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BFS遍历构造原始二叉树"><a href="#BFS遍历构造原始二叉树" class="headerlink" title="BFS遍历构造原始二叉树"></a>BFS遍历构造原始二叉树</h4><p><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树 hard</a></p><p><em><strong>多看看，直接用前序遍历的递归可以很快写出来。。。。</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rSerialize(root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    String[] dataArray = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    List&lt;String&gt; dataList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;(Arrays.asList(dataArray));</span><br><span class="line">    <span class="keyword">return</span> rDeserialize(dataList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">rSerialize</span><span class="params">(TreeNode root, String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        str += <span class="string">&quot;None,&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str += root.val + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        str = rSerialize(root.left, str);</span><br><span class="line">        str = rSerialize(root.right, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">rDeserialize</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dataList.get(<span class="number">0</span>).equals(<span class="string">&quot;None&quot;</span>)) &#123;</span><br><span class="line">        dataList.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(dataList.get(<span class="number">0</span>)));</span><br><span class="line">    dataList.remove(<span class="number">0</span>);</span><br><span class="line">    root.left = rDeserialize(dataList);</span><br><span class="line">    root.right = rDeserialize(dataList);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="描述一种场景，构造一个符合条件的二叉树"><a href="#描述一种场景，构造一个符合条件的二叉树" class="headerlink" title="描述一种场景，构造一个符合条件的二叉树"></a>描述一种场景，构造一个符合条件的二叉树</h4><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树 middle</a></p><p>这个递归比较简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> constructMaximumBinaryTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先找到最大的</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> startIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= endIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; maxNum) &#123;</span><br><span class="line">            maxNum = nums[i];</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxNum, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    root.left = constructMaximumBinaryTree(nums, startIndex, maxIndex - <span class="number">1</span>);</span><br><span class="line">    root.right = constructMaximumBinaryTree(nums, maxIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/complete-binary-tree-inserter/">919. 完全二叉树插入器 middle</a></p><p>这一题难度不大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 先对二叉树进行层序遍历，维护每一层的list，如果发现某一层的数量未达到上一层的2倍，就在这一层添加</span></span><br><span class="line">    List&lt;List&lt;TreeNode&gt;&gt; nodeLists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">    List&lt;TreeNode&gt; tmpList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (poll.val != -<span class="number">1</span>) &#123;</span><br><span class="line">            tmpList.add(poll);</span><br><span class="line">            <span class="keyword">if</span> (poll.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(poll.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (poll.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodeLists.add(tmpList);</span><br><span class="line">            tmpList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nodeLists.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        root.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;TreeNode&gt; parentLevel = nodeLists.get(nodeLists.size() - <span class="number">2</span>);</span><br><span class="line">    List&lt;TreeNode&gt; childLevel = nodeLists.get(nodeLists.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (childLevel.size() == parentLevel.size() * <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">fatherNode</span> <span class="operator">=</span> childLevel.get(<span class="number">0</span>);</span><br><span class="line">        fatherNode.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> fatherNode.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">fatherNode</span> <span class="operator">=</span> parentLevel.get(childLevel.size() / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (childLevel.size() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        fatherNode.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fatherNode.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fatherNode.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树构建"><a href="#二叉搜索树构建" class="headerlink" title="二叉搜索树构建"></a>二叉搜索树构建</h3><p><em><strong>普通二叉树无法根据一种序列重构的原因是只知道根节点，无法区分左右子树。如果是二叉搜索树，那么就有可能根据一种遍历序列构造出来。 原因就在于二叉搜索树的根节点的值大于所有的左子树的值，且小于所有的右子树的值。因此我们可以根据这一特性去确定左右子树的位置，经过这样的转换就和上面的普通二叉树没有啥区别了</strong></em><br><a href="https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/">1008. 前序遍历构造二叉搜索树 middle</a></p><p>这一题也比较简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">bstFromPreorder</span><span class="params">(<span class="type">int</span>[] preorder)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bstFromPreorder(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">bstFromPreorder</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[startIndex]);</span><br><span class="line">    <span class="keyword">if</span> (startIndex == endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> preorder[startIndex];</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> startIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex + <span class="number">1</span>; i &lt;= endIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder[i] &gt; maxVal) &#123;</span><br><span class="line">            rightIndex = i;</span><br><span class="line">            maxVal = preorder[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxVal == preorder[startIndex]) &#123;</span><br><span class="line">        <span class="comment">// 说明没有→子树</span></span><br><span class="line">        rightIndex = endIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root.left = bstFromPreorder(preorder, startIndex + <span class="number">1</span>, rightIndex - <span class="number">1</span>);</span><br><span class="line">    root.right = bstFromPreorder(preorder, rightIndex, endIndex);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改类"><a href="#修改类" class="headerlink" title="修改类"></a>修改类</h2><h3 id="题目要求的修改，-删除节点或者修改节点的值or指向"><a href="#题目要求的修改，-删除节点或者修改节点的值or指向" class="headerlink" title="题目要求的修改， 删除节点或者修改节点的值or指向"></a>题目要求的修改， 删除节点或者修改节点的值or指向</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针 middle</a></p><p><em><strong>BFS然后遍历，指向下一个就可以了</strong></em></p><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点 middle</a></p><blockquote><p>这一题需要一些技巧，要把每一种情况都梳理出来，并且为了方便，用到了虚拟的父亲节点</p></blockquote><p>根据二叉搜索树的性质</p><ol><li>如果目标节点大于当前节点值，则去右子树中删除；</li><li>如果目标节点小于当前节点值，则去左子树中删除；</li><li>如果目标节点就是当前节点，分为以下三种情况：<ol><li>其无左子：其右子顶替其位置，删除了该节点；</li><li>其无右子：其左子顶替其位置，删除了该节点；</li><li>其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。</li></ol></li></ol><p><img src="assets/img/posts/20220608/deleteNode.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">fakeFather</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">10000000</span>, root, <span class="literal">null</span>);</span><br><span class="line">    deleteNode(root, fakeFather, <span class="literal">true</span>, key);</span><br><span class="line">    <span class="keyword">return</span> fakeFather.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(TreeNode root, TreeNode father, <span class="type">boolean</span> left, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val != key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">            <span class="comment">// 找右子树</span></span><br><span class="line">            deleteNode(root.right, root, <span class="literal">false</span>,  key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deleteNode(root.left, root, <span class="literal">true</span>,  key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left) &#123;</span><br><span class="line">            father.left = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            father.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点，分三种情况</span></span><br><span class="line">    <span class="comment">// 1. 没有左子树，有右子树，右子树充当当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left) &#123;</span><br><span class="line">            father.left = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            father.right = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 没有右子树，有左子树， 左子树充当当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left) &#123;</span><br><span class="line">            father.left = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            father.right = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 都有的情况下， 将左子树放到右子树的最左节点的左孩子, 再将右子树放到当前位置</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">rightLeftNode</span> <span class="operator">=</span> findLeftLeaf(root.right);</span><br><span class="line">    rightLeftNode.left = root.left;</span><br><span class="line">    <span class="keyword">if</span> (left) &#123;</span><br><span class="line">        father.left = root.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        father.right = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title function_">findLeftLeaf</span><span class="params">(TreeNode right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findLeftLeaf(right.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树 middle</a></p><p>这道题是上面那道题的变种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">fakeFather</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">100000</span>, root, <span class="literal">null</span>);</span><br><span class="line">    doTrimBST(root, fakeFather, <span class="literal">true</span>, low, high);</span><br><span class="line">    <span class="keyword">return</span> fakeFather.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doTrimBST</span><span class="params">(TreeNode root, TreeNode father, <span class="type">boolean</span> isLeft, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分为几种情况：</span></span><br><span class="line">    <span class="comment">// 1. 当前节点在low和high之间 low &lt;= root.val &lt;= high</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &gt;= low &amp;&amp; root.val &lt;= high) &#123;</span><br><span class="line">        doTrimBST(root.left, root, <span class="literal">true</span>, low, root.val);</span><br><span class="line">        doTrimBST(root.right, root, <span class="literal">false</span>, root.val, high);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 当前节点的值小于low， 继续像当前节点的右子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">        doTrimBST(root.left, root, <span class="literal">true</span>, low, high);</span><br><span class="line">        doTrimBST(root.right, root, <span class="literal">false</span>, low, high);</span><br><span class="line">        <span class="comment">// 需要删除当前节点</span></span><br><span class="line">        delete(root, father, isLeft);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 当前节点的值大于high， 继续像当前节点的左子树递归</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">        doTrimBST(root.left, root, <span class="literal">true</span>, low, high);</span><br><span class="line">        doTrimBST(root.right, root, <span class="literal">false</span>, low, high);</span><br><span class="line">        <span class="comment">// 需要删除当前节点</span></span><br><span class="line">        delete(root, father, isLeft);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(TreeNode root, TreeNode father, <span class="type">boolean</span> isLeft)</span> &#123;</span><br><span class="line">    <span class="comment">// 走删除的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">            father.left = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            father.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">            father.left = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            father.right = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">            father.left = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            father.right = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">rightLeftNode</span> <span class="operator">=</span> findLeftNode(root.right);</span><br><span class="line">    rightLeftNode.left = root.left;</span><br><span class="line">    <span class="keyword">if</span> (isLeft) &#123;</span><br><span class="line">        father.left = root.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        father.right = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title function_">findLeftNode</span><span class="params">(TreeNode right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findLeftNode(right.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法需要，自己修改"><a href="#算法需要，自己修改" class="headerlink" title="算法需要，自己修改"></a>算法需要，自己修改</h3><p>这种是为了方便计算，自己增加了一个指针<br><a href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点 middle</a></p><p><em><strong>这一题需要维护父节点的映射，并标记访问过的节点进行去重，其他的仍然用递归的思路解决</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistanceK</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, TreeNode&gt; fatherMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">0</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>,</span><br><span class="line">                        <span class="literal">null</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>, <span class="literal">null</span>, <span class="literal">null</span>)))),</span><br><span class="line">                <span class="literal">null</span></span><br><span class="line">        );</span><br><span class="line">        List&lt;Integer&gt; integers = distanceK(root, root.left.right.right, <span class="number">0</span>);</span><br><span class="line">        System.out.println(integers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        fatherMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        dfs(root);</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; integers = doDistanceK(root, target, k);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> integers.stream().distinct().collect(Collectors.toList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> integers.stream().filter(val -&gt; val != target.val).distinct().collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            fatherMap.put(root.left.val, root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            fatherMap.put(root.right.val, root);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">doDistanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(target.val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(target.val);</span><br><span class="line">            visited.add(target.val);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.add(target.val);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">father</span> <span class="operator">=</span> fatherMap.get(target.val);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.addAll(doDistanceK(root, target.left, k - <span class="number">1</span>));</span><br><span class="line">            result.addAll(doDistanceK(root, target.right, k - <span class="number">1</span>));</span><br><span class="line">            result.addAll(doDistanceK(root, father, k - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四个重要概念"><a href="#四个重要概念" class="headerlink" title="四个重要概念"></a>四个重要概念</h1><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树具有下列性质的二叉树：</p><ul><li>若左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点。</li></ul><p><strong>天生适合查找</strong></p><p><strong>中序遍历是有序的</strong></p><p>二叉搜索树的中序遍历的结果是一个有序数组. <a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树 middle</a> 就可以利用这个特性</p><p><a href="https://leetcode.cn/problems/recover-binary-search-tree/">99. 恢复二叉搜索树 middle</a></p><p><strong>依然是使用中序遍历有序的特性，遍历的时候使用hashmap记录下，最后将顺序不对的调换即可</strong></p><p><a href="https://leetcode.cn/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器 middle</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">     list = dfs(root);</span><br><span class="line">     index = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">     List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">     <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">     result.addAll(dfs(root.left));</span><br><span class="line">     result.add(root.val);</span><br><span class="line">     result.addAll(dfs(root.right));</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> list.get(index++);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> index &lt; list.size();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p><p>如下就是一颗完全二叉树：<br><img src="assets/img/posts/20220608/completeTree.jpeg"></p><p>我们可以给完全二叉树编号，这样父子之间就可以通过编号轻松求出。比如我给所有节点从左到右从上到下依次从 1 开始编号。那么已知一个节点的编号是 i，那么其左子节点就是 2i，右子节点就是 2i + 1，父节点就是 i &#x2F; 2。<br>熟悉二叉堆的同学可能发现了，这就是用数组实现的二叉堆，其实二叉堆就是完全二叉树的一个应用。</p><p>有的同学会说，”但是很多题目都不是完全二叉树呀，那不是用不上了么？“其实不然，我们只要想象它存在即可，我们将空节点脑补上去不就可以了</p><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数 middle</a></p><p>这一题直接遍历或者递归就行了，比较简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度 middle</a></p><p>这一题要利用完全二叉树的下标来简化计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">    root.val = <span class="number">0</span>;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.MIN_VALUE, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">    List&lt;Integer&gt; tmpList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (poll.val != Integer.MIN_VALUE) &#123;</span><br><span class="line">            tmpList.add(poll.val);</span><br><span class="line">            <span class="keyword">if</span> (poll.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                poll.left.val = <span class="number">2</span> * poll.val + <span class="number">1</span>;</span><br><span class="line">                queue.add(poll.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (poll.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                poll.right.val = <span class="number">2</span> * poll.val + <span class="number">2</span>;</span><br><span class="line">                queue.add(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSize</span> <span class="operator">=</span> getWidth(tmpList);</span><br><span class="line">        <span class="keyword">if</span> (curSize &gt; maxWidth) &#123;</span><br><span class="line">            maxWidth = curSize;</span><br><span class="line">        &#125;</span><br><span class="line">        tmpList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.MIN_VALUE, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxWidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getWidth</span><span class="params">(List&lt;Integer&gt; integers)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (integers == <span class="literal">null</span> || integers.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (integers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> integers.get(integers.size() - <span class="number">1</span>) - integers.get(<span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>经典题：<br><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">124. 二叉树中的最大路径和 hard</a></p><p>树的题目，基本都是考察递归思想的。因此我们需要思考如何去定义我们的递归函数，在这里我定义了一个递归函数，它的功能是，返回以当前节点为根节点的MaxPath</p><p>但是有两个条件:</p><ol><li>根节点必须选择</li><li>左右子树只能选择一个</li></ol><p>为什么要有这两个条件?</p><p>我的想法是原问题可以转化为：以每一个节点为根节点，分别求出 MaxPath，最后计算最大值，因此第一个条件需要满足.</p><p>对于第二个条件，由于递归函数子节点的返回值会被父节点使用，因此我们如果两个孩子都选择了就不符合 MaxPath 的定义了。实际上这道题，当遍历到某一个节点的时候，我们需要子节点的信息，然后同时结合自身的 val 来决定要不要选取左右子树以及选取的话要选哪一个， 因此这个过程本质上就是后序遍历</p><p>基本算法就是不断调用递归函数，然后在调用过程中不断计算和更新 MaxPath，最后在主函数中将 MaxPath 返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPathSum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>));</span><br><span class="line">        <span class="type">MaxPathSum</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MaxPathSum</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pathSum</span> <span class="operator">=</span> sum.maxPathSum(root);</span><br><span class="line">        System.out.println(pathSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxGain</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> Math.max(maxGain(root.left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> Math.max(maxGain(root.right), <span class="number">0</span>);</span><br><span class="line">        ans = Math.max(root.val + leftMax + rightMax, ans);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMax + root.val, rightMax + root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II middle</a></p><p><strong>这道题还是很经典的，要多看几遍</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; tmpPath = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>), <span class="literal">null</span>), <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>), <span class="literal">null</span>));</span><br><span class="line">    <span class="type">PathSum2</span> <span class="variable">pathSum2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathSum2</span>();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; lists = pathSum2.pathSum(root, <span class="number">8</span>);</span><br><span class="line">    System.out.println(lists);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    doPathSum(root, targetSum);</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmpPath.add(root.val);</span><br><span class="line">    targetSum = targetSum - root.val;</span><br><span class="line">    <span class="keyword">if</span> (targetSum == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        paths.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmpPath));</span><br><span class="line">    &#125;</span><br><span class="line">    doPathSum(root.left, targetSum);</span><br><span class="line">    doPathSum(root.right, targetSum);</span><br><span class="line">    tmpPath.remove(tmpPath.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sum-of-distances-in-tree/description/">834. 树中距离之和 hard</a></p><p><em><strong>这个以后再挑战吧</strong></em></p><h1 id="七个技巧"><a href="#七个技巧" class="headerlink" title="七个技巧"></a>七个技巧</h1><h2 id="单-双递归"><a href="#单-双递归" class="headerlink" title="单&#x2F;双递归"></a>单&#x2F;双递归</h2><p>单递归大家写的比较多了，其实本篇文章的大部分递归都是单递归。 那什么时候需要两个递归呢？其实我上面已经提到了，那就是如果题目有类似，任意节点开始 xxxx 或者所有 xxx这样的说法，就可以考虑使用双递归。但是如果递归中有重复计算，则可以使用双递归 + 记忆化 或者直接单递归。</p><p>双递归的基本套路就是一个主递归函数和一个内部递归函数。主递归函数负责计算以某一个节点开始的 xxxx，内部递归函数负责计算 xxxx，这样就实现了以所有节点开始的 xxxx。</p><blockquote><p>其中 xxx 可以替换成任何题目描述，比如路径和等</p></blockquote><p>一个典型的加法双递归是这样的：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> dfs_inner(root):</span><br><span class="line">    # 这里写你的逻辑，就是前序遍历</span><br><span class="line">    dfs_inner(root.left)</span><br><span class="line">    dfs_inner(root.right)</span><br><span class="line">    # 或者在这里写你的逻辑，那就是后序遍历</span><br><span class="line"><span class="keyword">def</span> dfs_main(root):</span><br><span class="line">    <span class="keyword">return</span> dfs_inner(root) + dfs_main(root.left) + dfs_main(root.right)</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/paths-with-sum-lcci/">面试题 04.12. 求和路径 middle</a><br><strong>参考上面的双递归模板</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doPathSum(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">doPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newSum</span> <span class="operator">=</span> sum - root.val;</span><br><span class="line">    <span class="keyword">if</span> (newSum == <span class="number">0</span>) &#123;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res + doPathSum(root.left, newSum) + doPathSum(root.right, newSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/binary-tree-tilt/description/">563. 二叉树的坡度 easy</a></p><p><strong>一样的，套双递归的模板就可以了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTilt</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootTilt</span> <span class="operator">=</span> doFindTilt(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftTilt</span> <span class="operator">=</span> findTilt(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightTilt</span> <span class="operator">=</span> findTilt(root.right);</span><br><span class="line">    <span class="keyword">return</span> rootTilt + leftTilt + rightTilt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doFindTilt</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(sum(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(sum(root.left));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(sum(root.left) - sum(root.right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(TreeNode left)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (left == <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> left.val + sum(left.left) + sum(left.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前后遍历"><a href="#前后遍历" class="headerlink" title="前后遍历"></a>前后遍历</h2><p><strong>如果是前序遍历，那么你可以想象上面的节点都处理好了，怎么处理的不用管。相应地如果是后序遍历，那么你可以想象下面的树都处理好了，怎么处理的不用管</strong></p><p><em><strong>前后序对链表来说比较直观。对于树来说，其实更形象地说应该是自顶向下或者自底向上。自顶向下和自底向上在算法上是不同的，不同的写法有时候对应不同的书写难度。</strong></em></p><ul><li>自顶向下就是在每个递归层级，首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点，一般是通过参数传到子树中。 </li><li>自底向上是另一种常见的递归方法，首先对所有子节点递归地调用函数，然后根据返回值和根节点本身的值得到答案。</li></ul><p><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和 middle</a></p><p><strong>这道题就适合用前序遍历 + 扩展参数来做, 掌握了技巧就很简单</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppendNumbersInTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; sums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        doSum(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer value : sums) &#123;</span><br><span class="line">            res += value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            sums.add(Integer.valueOf(sb.toString()));</span><br><span class="line">        &#125;</span><br><span class="line">        doSum(root.left);</span><br><span class="line">        doSum(root.right);</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-good-nodes-in-binary-tree/">1448. 统计二叉树中好节点的数目</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">goodNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">preMax</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">return</span> doGoodNodes(root, preMax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">doGoodNodes</span><span class="params">(TreeNode root, <span class="type">int</span> preMax)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt;= preMax) &#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        preMax = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt + doGoodNodes(root.left, preMax) + doGoodNodes(root.right, preMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>大多数树的题使用后序遍历比较简单，并且大多需要依赖左右子树的返回值。比如 <a href="https://leetcode.cn/problems/count-good-nodes-in-binary-tree/">1448. 统计二叉树中好节点的数目</a> </li><li>不多的问题需要前序遍历，而前序遍历通常要结合参数扩展技巧。比如 <a href="https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/">1022. 从根到叶的二进制数之和</a> </li><li>如果你能使用参数和节点本身的值来决定什么应该是传递给它子节点的参数，那就用前序遍历。 </li><li>如果对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出当前节点的答案，那就用后序遍历。 </li><li>如果遇到二叉搜索树则考虑中序遍历</li></ul><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p><a href="https://leetcode.cn/problems/binary-tree-pruning/">814. 二叉树剪枝 middle</a></p><p><strong>掌握套路之后这一题也简单的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> TreeNode <span class="title function_">pruneTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">fakeRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>, root, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    doPruneTree(root, fakeRoot, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> fakeRoot.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doPruneTree</span><span class="params">(TreeNode root, TreeNode father, <span class="type">boolean</span> left)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oneCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> oneCnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == <span class="number">1</span>) &#123;</span><br><span class="line">        oneCnt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftOneCnt</span> <span class="operator">=</span> doPruneTree(root.left, root, <span class="literal">true</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightOneCnt</span> <span class="operator">=</span> doPruneTree(root.right, root, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftOneCnt == <span class="number">0</span> &amp;&amp; rightOneCnt == <span class="number">0</span> &amp;&amp; oneCnt == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除当前子树</span></span><br><span class="line">        <span class="keyword">if</span> (left) &#123;</span><br><span class="line">            father.left = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            father.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftOneCnt + rightOneCnt + oneCnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展参数"><a href="#扩展参数" class="headerlink" title="扩展参数"></a>扩展参数</h2><p>最典型的有三种：</p><ol><li><p>携带父亲或者爷爷的信息，或者携带方向信息</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> dfs(root, parent):</span><br><span class="line">    <span class="keyword">if</span> not <span class="attr">root:</span> <span class="keyword">return</span></span><br><span class="line">    dfs(root.left, root)</span><br><span class="line">    dfs(root.right, root)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>携带路径信息，可以是路径和或者路径数组</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">路径和</span><br><span class="line"><span class="keyword">def</span> dfs(root, path_sum):</span><br><span class="line">    <span class="keyword">if</span> not <span class="attr">root:</span></span><br><span class="line">        # 这里可以拿到根到叶子的路径和</span><br><span class="line">        <span class="keyword">return</span> path_sum</span><br><span class="line">    dfs(root.left, path_sum + root.val)</span><br><span class="line">    dfs(root.right, path_sum + root.val)</span><br><span class="line"></span><br><span class="line">路径</span><br><span class="line"><span class="keyword">def</span> dfs(root, path):</span><br><span class="line">    <span class="keyword">if</span> not <span class="attr">root:</span></span><br><span class="line">        # 这里可以拿到根到叶子的路径</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    path.append(root.val)</span><br><span class="line">    dfs(root.left, path)</span><br><span class="line">    dfs(root.right, path)</span><br><span class="line">    # 撤销</span><br><span class="line">    path.pop()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>二叉搜索树的搜索题大多数都需要扩展参数，甚至怎么扩展都是固定的。</p></li></ol><blockquote><p>二叉搜索树的搜索总是将最大值和最小值通过参数传递到左右子树，类似 dfs(root, lower, upper)，然后在递归过程更新最大和最小值即可。这里需要注意的是 (lower, upper) 是的一个左右都开放的区间。</p></blockquote><p><a href="https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/">1026. 节点与其祖先之间的最大差值 middle</a></p><p><strong>通过维护一条路径的最大值和最小值的边界，到叶子节点的时候计算差值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAncestorDiff</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doMaxAncestorDiff(root, root.val, root.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doMaxAncestorDiff</span><span class="params">(TreeNode root, <span class="type">int</span> minVal, <span class="type">int</span> maxVal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(maxVal - minVal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; maxVal) &#123;</span><br><span class="line">        maxVal = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; minVal) &#123;</span><br><span class="line">        minVal = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(doMaxAncestorDiff(root.left, minVal, maxVal), doMaxAncestorDiff(root.right, minVal, maxVal));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/">865. 具有所有最深节点的最小子树 middle</a></p><p>有一点点难度， 思考路径：</p><ol><li>递归需要同时返回深度和节点</li><li>是自上而下， 因此前序遍历</li><li>遍历的时候带上扩展参数：当前深度、父亲节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">subtreeWithAllDeepest</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> dfs(root, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> result == <span class="literal">null</span> ? <span class="literal">null</span> : result.node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Result <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> lastDepth, TreeNode father)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (father == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(root, lastDepth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (father.left != <span class="literal">null</span> &amp;&amp; father.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(father, lastDepth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(root, lastDepth + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left, lastDepth + <span class="number">1</span>, root);</span><br><span class="line">    <span class="type">Result</span> <span class="variable">right</span> <span class="operator">=</span> dfs(root.right, lastDepth + <span class="number">1</span>, root);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left.depth == right.depth) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(root, left.depth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left.depth &gt; right.depth) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> depth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(TreeNode node, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.node = node;</span><br><span class="line">        <span class="built_in">this</span>.depth = depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs/">1530. 好叶子节点对的数量 middle</a></p><p><strong>写起来有一点复杂的，可以好好复习下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountGoodPairs</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">finalAns</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CountGoodPairs</span> <span class="variable">countGoodPairs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountGoodPairs</span>();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(</span><br><span class="line">                <span class="number">1</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TreeNode</span>(</span><br><span class="line">                        <span class="number">2</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>)</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TreeNode</span>(</span><br><span class="line">                        <span class="number">3</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">6</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">7</span>)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="type">int</span> <span class="variable">pairs</span> <span class="operator">=</span> countGoodPairs.countPairs(root, <span class="number">3</span>);</span><br><span class="line">        System.out.println(pairs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPairs</span><span class="params">(TreeNode root, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">        finalAns = <span class="number">0</span>;</span><br><span class="line">        countDistances(root, distance);</span><br><span class="line">        <span class="keyword">return</span> finalAns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">countDistances</span><span class="params">(TreeNode root, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            result.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; distancesLeft = countDistances(root.left, distance);</span><br><span class="line">        List&lt;Integer&gt; distanceRight = countDistances(root.right, distance);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer left : distancesLeft) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer right : distanceRight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left + right &lt;= distance) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        finalAns += ans;</span><br><span class="line"></span><br><span class="line">        result.addAll(distancesLeft);</span><br><span class="line">        result.addAll(distanceRight);</span><br><span class="line">        result = result.stream().map(dis -&gt; dis + <span class="number">1</span>).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/all-possible-full-binary-trees/">894. 所有可能的满二叉树 middle</a></p><p><strong>这一题蛮困难的，没做出来</strong></p><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><p><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树 easy</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span> || right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.val == right.val &amp;&amp; isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树 easy</a></p><p><strong>经典的简单题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    tmp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = tmp;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径 easy</a></p><p><strong>一开始自己居然没有写出来，其实就是以当前节点的视角看，左右深度相加，在遍历root的时候维护一个最大值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    maxVal = <span class="number">0</span>;</span><br><span class="line">    doDiameterOfBinaryTree(root);</span><br><span class="line">    <span class="keyword">return</span> maxVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">doDiameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftCnt</span> <span class="operator">=</span> doDiameterOfBinaryTree(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightCnt</span> <span class="operator">=</span> doDiameterOfBinaryTree(root.right);</span><br><span class="line">    <span class="type">int</span> <span class="variable">curVal</span> <span class="operator">=</span> leftCnt + rightCnt;</span><br><span class="line">    <span class="keyword">if</span> (curVal &gt; maxVal) &#123;</span><br><span class="line">        maxVal = curVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftCnt, rightCnt) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/">971. 翻转二叉树以匹配先序遍历 middle</a></p><p><strong>没做出来</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;二叉树分类&quot;&gt;&lt;a href=&quot;#二叉树分类&quot; class=&quot;headerlink&quot; title=&quot;二叉树分类&quot;&gt;</summary>
      
    
    
    
    <category term="面试" scheme="https://blog.cuznlp.cn/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://blog.cuznlp.cn/categories/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="面试" scheme="https://blog.cuznlp.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://blog.cuznlp.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>链表题，掌握这些，就可以啦</title>
    <link href="https://blog.cuznlp.cn/2022/06/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E7%AE%97%E6%B3%95%E9%A2%98-%E9%93%BE%E8%A1%A8/"/>
    <id>https://blog.cuznlp.cn/2022/06/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-%E7%AE%97%E6%B3%95%E9%A2%98-%E9%93%BE%E8%A1%A8/</id>
    <published>2022-06-05T13:41:07.000Z</published>
    <updated>2023-08-27T13:57:28.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/linked-list.md">原教程链接</a></p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>数组和链表<ul><li>数组和链表只是使用物理内存的两种方式。数组是连续的内存空间，通常每一个单位的大小也是固定的，因此可以按下标随机访问。而链表则不一定连续，因此其查找只能依靠别的方式，一般我们是通过一个叫 next 指针来遍历查找。</li><li>数组是一块连续的空间，数组的每一项都是紧密相连的，因此如果要执行插入和删除操作就很麻烦。对数组头部的插入和删除时间复杂度都是O(n)，而平均复杂度也是O(n)，只有对尾部的插入和删除才是O(1)。简单来说”数组对查询特别友好，对删除和添加不友好“。为了解决这个问题，就有了链表这种数据结构。链表适合在数据需要有一定顺序，但是又需要进行频繁增删除的场景</li></ul></li></ul><h1 id="一个原则"><a href="#一个原则" class="headerlink" title="一个原则"></a>一个原则</h1><p>画图,通过将一部分认知负担转嫁到纸上来节省自己的思维带宽</p><h1 id="两个考点"><a href="#两个考点" class="headerlink" title="两个考点"></a>两个考点</h1><h2 id="指针修改"><a href="#指针修改" class="headerlink" title="指针修改"></a>指针修改</h2><p>典型题： 链表反转</p><blockquote><p>链表是一种递归的数据结构，因此采用递归的思想去考虑往往事半功倍</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 头节点插入法  时间复杂度O(n), 空间复杂度O(1)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LinkedList <span class="title function_">reverse</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">last</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">next</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">    LinkedList temp;</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">        temp = next;</span><br><span class="line">        next = next.getNext();</span><br><span class="line">        temp.setNext(head);</span><br><span class="line">        head = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    last.setNext(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用栈做反转链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LinkedList <span class="title function_">reverseByStack</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">next</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;LinkedList&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(head);</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(next);</span><br><span class="line">        next = next.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">newHead</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> newHead;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        cur.setNext(stack.pop());</span><br><span class="line">        cur = cur.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    cur.setNext(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用三指针法 时间复杂度O(n), 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LinkedList <span class="title function_">reverseByThreePointer</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.getNext() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">next</span> <span class="operator">=</span> cur.getNext();</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">nextNext</span> <span class="operator">=</span> next.getNext();</span><br><span class="line">        cur.setNext(pre);</span><br><span class="line">        next.setNext(cur);</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = nextNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表拼接"><a href="#链表拼接" class="headerlink" title="链表拼接"></a>链表拼接</h2><h3 id="典型题：-21-合并有序链表-easy"><a href="#典型题：-21-合并有序链表-easy" class="headerlink" title="典型题： 21 合并有序链表 [easy]"></a>典型题： 21 合并有序链表 [easy]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList <span class="title function_">combine</span><span class="params">(LinkedList head1, LinkedList head2)</span> &#123;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head1 == <span class="literal">null</span> ? head2 : head1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head1.getCnt() &gt; head2.getCnt()) &#123;</span><br><span class="line">        newHead = head2;</span><br><span class="line">        newHead.setNext(combine(head1, head2.getNext()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newHead = head1;</span><br><span class="line">        newHead.setNext(combine(head1.getNext(), head2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三个注意"><a href="#三个注意" class="headerlink" title="三个注意"></a>三个注意</h1><ul><li>出现了环，造成死循环。</li><li>分不清边界，导致边界条件出错。</li><li>搞不懂递归怎么做</li></ul><h2 id="环"><a href="#环" class="headerlink" title="环"></a>环</h2><p>判断是否有环，以及环的位置： <strong>快慢指针算法</strong></p><h3 id="判断环"><a href="#判断环" class="headerlink" title="判断环"></a>判断环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasCircle</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.getNext().getNext();</span><br><span class="line">        slow = slow.getNext();</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环的长度"><a href="#环的长度" class="headerlink" title="环的长度"></a>环的长度</h3><p><em><strong>快慢指针第二次相遇的时候，距离第一次相遇，慢指针走了一圈环的长度</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">circleLength</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.getNext().getNext();</span><br><span class="line">        slow = slow.getNext();</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="comment">// 第一次相遇</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">                fast = fast.getNext().getNext();</span><br><span class="line">                slow = slow.getNext();</span><br><span class="line">                cnt ++;</span><br><span class="line">                <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环的入口"><a href="#环的入口" class="headerlink" title="环的入口"></a>环的入口</h3><p><em><strong>当两个指针相遇后，其中一个回到head，每次一起向后走一步，再次相遇，就在环的入口</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当两个指针相遇后，其中一个回到head，每次一起向后走一步，再次相遇，就在环的入口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList <span class="title function_">findCircle</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.getNext().getNext();</span><br><span class="line">        slow = slow.getNext();</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">                fast = fast.getNext();</span><br><span class="line">                slow = slow.getNext();</span><br><span class="line">                <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                    <span class="keyword">return</span> fast;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四个技巧"><a href="#四个技巧" class="headerlink" title="四个技巧"></a>四个技巧</h1><h2 id="虚拟头"><a href="#虚拟头" class="headerlink" title="虚拟头"></a>虚拟头</h2><ul><li>将头节点变成中间节点，简化判断。</li><li>通过在合适的时候断开链接，返回链表的中间节点。</li></ul><h3 id="例题：25-K-个一组翻转链表-hard"><a href="#例题：25-K-个一组翻转链表-hard" class="headerlink" title="例题：25. K 个一组翻转链表 [hard]"></a>例题：25. K 个一组翻转链表 [hard]</h3><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>示例：</p><p>给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>当 k &#x3D; 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>当 k &#x3D; 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p><p>说明：</p><p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><em><strong>这里没发现要用到虚拟头</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList <span class="title function_">reverseInK</span><span class="params">(LinkedList head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">kLast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (kLast.getNext() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先找到第k个</span></span><br><span class="line">        kLast = kLast.getNext();</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">nextHead</span> <span class="operator">=</span> kLast.getNext();</span><br><span class="line">    kLast.setNext(<span class="literal">null</span>);</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">reverseHead</span> <span class="operator">=</span> reverse(head);</span><br><span class="line">    <span class="comment">// 找到新的last</span></span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">reverseLast</span> <span class="operator">=</span> findLast(reverseHead);</span><br><span class="line">    <span class="comment">// 后面的用递归</span></span><br><span class="line">    reverseLast.setNext(reverseInK(nextHead, k));</span><br><span class="line">    <span class="keyword">return</span> reverseHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList <span class="title function_">reverse</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">next</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">nextNext</span> <span class="operator">=</span> next.getNext();</span><br><span class="line">        cur.setNext(pre);</span><br><span class="line">        next.setNext(cur);</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = nextNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList <span class="title function_">findLast</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        head = head.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><blockquote><p>由于链表不支持随机访问，因此如果想要获取数组中间项和倒数第几项等特定元素就需要一些特殊的手段，而这个手段就是快慢指针。比如要找链表中间项就搞两个指针，一个大步走（一次走两步），一个小步走（一次走一步），这样快指针走到头，慢指针刚好在中间。 如果要求链表倒数第 2 个，那就让快指针先走一步，慢指针再走，这样快指针走到头，慢指针刚好在倒数第二个。这个原理不难理解吧？这种技巧属于会了就容易，且不容易忘。不会就很难想出的类型，因此大家学会了拿几道题练一下就可以放下了。</p></blockquote><h2 id="穿针引线"><a href="#穿针引线" class="headerlink" title="穿针引线"></a>穿针引线</h2><h3 id="例题：61-旋转链表-middle"><a href="#例题：61-旋转链表-middle" class="headerlink" title="例题：61. 旋转链表 [middle]"></a>例题：61. 旋转链表 [middle]</h3><p><a href="https://leetcode.cn/problems/rotate-list/">题目地址</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList <span class="title function_">rotate</span><span class="params">(LinkedList head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> count(head);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rotateHeadCnt</span> <span class="operator">=</span> k % length;</span><br><span class="line">    <span class="keyword">if</span> (rotateHeadCnt == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">newHead</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; length - rotateHeadCnt) &#123;</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">pre</span> <span class="operator">=</span> newHead;</span><br><span class="line">        newHead = newHead.getNext();</span><br><span class="line">        <span class="comment">// 断掉原来的连接</span></span><br><span class="line">        <span class="keyword">if</span> (cnt == length - rotateHeadCnt - <span class="number">1</span>) &#123;</span><br><span class="line">            pre.setNext(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">oldLast</span> <span class="operator">=</span> getLast(newHead);</span><br><span class="line">    oldLast.setNext(head);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LinkedList <span class="title function_">getLast</span><span class="params">(LinkedList newHead)</span> &#123;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">oldLast</span> <span class="operator">=</span> newHead;</span><br><span class="line">    <span class="keyword">while</span> (oldLast.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldLast = oldLast.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldLast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        head = head.getNext();</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II middle</a></p><p><em><strong>这一题代码的小细节会比较多，用到了虚拟头</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList <span class="title function_">totalDeleteDuplicateEle</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>)  &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造一个虚拟的头结点</span></span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    newHead.setNext(head);</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">pre</span> <span class="operator">=</span> newHead;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">next</span> <span class="operator">=</span> cur.getNext();</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">nextNext</span> <span class="operator">=</span> next.getNext();</span><br><span class="line">        <span class="keyword">if</span> (cur.getCnt() == next.getCnt()) &#123;</span><br><span class="line">            <span class="type">LinkedList</span> <span class="variable">lastSame</span> <span class="operator">=</span> next;</span><br><span class="line">            <span class="keyword">while</span> (lastSame.getNext() != <span class="literal">null</span> &amp;&amp; lastSame.getNext().getCnt() == cur.getCnt()) &#123;</span><br><span class="line">                lastSame = lastSame.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把所有相同的都得断链</span></span><br><span class="line">            cur = lastSame.getNext();</span><br><span class="line">            pre.setNext(cur);</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                next = cur.getNext();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = nextNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.getNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">83. 删除排序链表中的重复元素 easy</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList <span class="title function_">deleteDuplicateEle</span><span class="params">(LinkedList head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>)  &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">next</span> <span class="operator">=</span> cur.getNext();</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">nextNext</span> <span class="operator">=</span> next.getNext();</span><br><span class="line">        <span class="keyword">if</span> (cur.getCnt() == next.getCnt()) &#123;</span><br><span class="line">            cur.setNext(nextNext);</span><br><span class="line">            next = nextNext;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = nextNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表 middle</a><br><em><strong>也用到了虚拟头</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newTail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    pre.setNext(head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.getNext();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">afterHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先从投=头开始找，找到第一个符合条件的作为新头，原来的旧的head保留不动，但是要有个变量保存起来</span></span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.getCnt() &lt; x) &#123;</span><br><span class="line">            pre.setNext(next);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newHead == <span class="literal">null</span>) &#123;</span><br><span class="line">                newHead = cur;</span><br><span class="line">                newTail = cur;</span><br><span class="line">                newTail.setNext(<span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 继续寻找，找到符合的，连到新头后面，原来的链表接续上</span></span><br><span class="line">                newTail.setNext(cur);</span><br><span class="line">                newTail = cur;</span><br><span class="line">                newTail.setNext(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (afterHead == <span class="literal">null</span>) &#123;</span><br><span class="line">                afterHead = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = cur.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (cur.getCnt() &lt; x) &#123;</span><br><span class="line">        pre.setNext(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (newTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            newTail.setNext(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        newTail = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后将新头的tail连到旧的head上</span></span><br><span class="line">    <span class="keyword">if</span> (newTail != <span class="literal">null</span>) &#123;</span><br><span class="line">        newTail.setNext(afterHead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a><br>主要是一些边界条件和特殊情况的处理比较麻烦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先找到子链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">beforeLeft</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">afterRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.getNext();</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; right &amp;&amp; next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == left) &#123;</span><br><span class="line">            leftNode = cur;</span><br><span class="line">            beforeLeft = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur.getNext();</span><br><span class="line">        next = cur.getNext();</span><br><span class="line">        cnt++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    rightNode = cur;</span><br><span class="line">    afterRight = cur.getNext();</span><br><span class="line">    <span class="comment">// 将子链表和原来的断开</span></span><br><span class="line">    <span class="keyword">if</span> (beforeLeft != <span class="literal">null</span>) &#123;</span><br><span class="line">        beforeLeft.setNext(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rightNode.setNext(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对子链表进行反转</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">subHead</span> <span class="operator">=</span> reverseList(leftNode);</span><br><span class="line">    <span class="comment">// 和原来的接起来</span></span><br><span class="line">    <span class="keyword">if</span> (beforeLeft != <span class="literal">null</span>) &#123;</span><br><span class="line">        beforeLeft.setNext(subHead);</span><br><span class="line">    &#125;</span><br><span class="line">    leftNode.setNext(afterRight);</span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表 middle</a></p><p><em><strong>这一题也属于是知道思路就会做</strong></em></p><p>首先我们可以忽略 random 指针，然后对原链表的每个节点进行复制，并追加到原节点的后面，而后复制 random 指针。最后我们把原链表和复制链表拆分出来，并将原链表复原。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">copyList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.getNext();</span><br><span class="line">    <span class="comment">// 每个节点复制一份插入在后面</span></span><br><span class="line">    <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">copyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(cur.getCnt(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        cur.setNext(copyNode);</span><br><span class="line">        copyNode.setNext(next);</span><br><span class="line">        cur = next;</span><br><span class="line">        next = cur.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">copyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(cur.getCnt(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    cur.setNext(copyNode);</span><br><span class="line">    copyNode.setRandomIndex(cur.getRandomIndex().getNext());</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">    newHead.setRandomIndex(head.getRandomIndex().getNext());</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> newHead.getNext();</span><br><span class="line">    cur = pre.getNext();</span><br><span class="line">    <span class="keyword">while</span> (cur.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        cur.setRandomIndex(pre.getRandomIndex().getNext());</span><br><span class="line">        newHead.setNext(cur);</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表 middle</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reOrder</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.getNext() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先用快慢指针把原来的一分为2</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast.getNext() !=  <span class="literal">null</span> &amp;&amp; fast.getNext().getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.getNext();</span><br><span class="line">        fast = fast.getNext().getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以slow为界</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">subHead</span> <span class="operator">=</span> slow.getNext();</span><br><span class="line">    slow.setNext(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转后面的链表</span></span><br><span class="line">    subHead = reverse(subHead);</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">index</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">subIndex</span> <span class="operator">=</span> subHead;</span><br><span class="line">    <span class="keyword">while</span> (subIndex != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nextIndex</span> <span class="operator">=</span> index.getNext();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nextSubIndex</span> <span class="operator">=</span> subIndex.getNext();</span><br><span class="line">        index.setNext(subIndex);</span><br><span class="line">        subIndex.setNext(nextIndex);</span><br><span class="line">        index = nextIndex;</span><br><span class="line">        subIndex = nextSubIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表 middle</a><br><em><strong>排序算法在链表中的使用</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">combineSort</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.getNext() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.getNext() == tail &amp;&amp; head.getCnt() &gt; tail.getCnt()) &#123;</span><br><span class="line">        <span class="comment">//  将head和tail进行反转</span></span><br><span class="line">        head.setNext(<span class="literal">null</span>);</span><br><span class="line">        tail.setNext(head);</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用快慢指针找到链表的中间节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast.getNext() != <span class="literal">null</span> &amp;&amp; fast.getNext().getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.getNext();</span><br><span class="line">        fast = fast.getNext().getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">nextHead</span> <span class="operator">=</span> slow.getNext();</span><br><span class="line">    slow.setNext(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 将链表分成两个部分，分别进行排序</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">part1</span> <span class="operator">=</span> combineSort(head, slow);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">part2</span> <span class="operator">=</span> combineSort(nextHead, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 将排序后的链表进行合并</span></span><br><span class="line">    <span class="keyword">return</span> combine(part1, part2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">combine</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head1 != <span class="literal">null</span> ? head1 : head2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head1.getCnt() &lt; head2.getCnt()) &#123;</span><br><span class="line">        newHead = head1;</span><br><span class="line">        newHead.setNext(combine(head1.getNext(), head2));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newHead = head2;</span><br><span class="line">        newHead.setNext(combine(head2.getNext(), head1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表 easy</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isBackWord</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast.getNext() != <span class="literal">null</span> &amp;&amp; fast.getNext().getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.getNext();</span><br><span class="line">        fast = fast.getNext().getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">nextHead</span> <span class="operator">=</span> slow.getNext();</span><br><span class="line">    nextHead = reverse(nextHead);</span><br><span class="line">    slow.setNext(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">index</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">subIndex</span> <span class="operator">=</span> nextHead;</span><br><span class="line">    <span class="keyword">while</span> (subIndex.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index.getCnt() == subIndex.getCnt()) &#123;</span><br><span class="line">            index = index.getNext();</span><br><span class="line">            subIndex = subIndex.getNext();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/azl397985856/leetcode/blob/master/thinkings/linked-list.md&quot;&gt;原教程链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;</summary>
      
    
    
    
    <category term="面试" scheme="https://blog.cuznlp.cn/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://blog.cuznlp.cn/categories/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="面试" scheme="https://blog.cuznlp.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://blog.cuznlp.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
